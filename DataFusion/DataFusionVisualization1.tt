<#@ template debug="false" hostspecific="true" language="C#" #><#@ output extension=".cs" #><#@ include file="..\packages\Baselabs.Statistics.Tooling.7.1.3303.3520\tools\Templating.t4" #><#@ assembly name="System.Drawing" #>// ------------------------------------------------------------------------------
// <auto-generated>
//      This code was generated by BASELABS Create.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
using  System;
using System.Collections.Generic ;
using System.Drawing;
using System.Linq;
using System.Threading;
using Baselabs.Statistics.Distributions;
using Baselabs.Statistics.Spaces;
using Baselabs.Statistics.Tracking.Tracks;
using Baselabs.Statistics.Visualization;
using OxyPlot;
using OxyPlot.Annotations;
using OxyPlot.Axes;
using OxyPlot.Series;
using SelectionMode = OxyPlot.SelectionMode;
using TickStyle = OxyPlot.Axes.TickStyle;

namespace <#=Namespace#>
{
    public partial class <#=ClassName#>Visualization
    {
        private readonly FieldOfViewAnnotation _fovAnnotation = new FieldOfViewAnnotation();
<#foreach(var sensor in model.Sensors){#>
        private readonly ScatterSeries _scatterSeries<#=sensor.Number#>;
<#}#>
        private TrackSeries _trackSeries;

        private readonly object _itemsLock = new object();
<#foreach(var sensor in model.Sensors){#>
        private DateTime _measurementsTime<#=sensor.Number#>;
        private IEnumerable<<#=sensor.MeasurementSpaceTypeName#>> _measurements<#=sensor.Number#>;

        private IEnumerable<<#=ClassName#>.Prediction<<#=model.System.StateSpaceTypeName#>, <#=sensor.MeasurementSpaceTypeName#>>> _predictions<#=sensor.Number#>;
        private IEnumerable<<#=ClassName#>.Association<<#=sensor.MeasurementSpaceTypeName#>>> _associations<#=sensor.Number#>;
<#}#>
        private DateTime _tracksTime;
        private IEnumerable<GaussianTrack<<#=model.System.StateSpaceTypeName#>>> _tracks;

        private const double XMinDefault = -250;
        private const double XMaxDefault = -XMinDefault;
        private const double YMinDefault = -50;
        private const double YMaxDefault = -YMinDefault;

        public const int DefaultPredictionTimeSpan = 1000;
        public const double DefaultExistenceProbabilityMin = 0.99;

        public <#=ClassName#>Visualization()
        {
            InitializeParameters();

            PlotModel = GetPlotModel(XMinDefault, XMaxDefault, YMinDefault, YMaxDefault);
<#foreach(var sensor in model.Sensors){#>
            var palette<#=sensor.Number#> = CreatePalette(Color.FromArgb(<#=sensor.Color.R#>, <#=sensor.Color.G#>, <#=sensor.Color.B#>));
            var colorAxis<#=sensor.Number#> = new LinearColorAxis
            {
                Minimum = 0,
                Maximum = 1,
                Palette = palette<#=sensor.Number#>,
            };
            PlotModel.Axes.Add(colorAxis<#=sensor.Number#>);

            _fovAnnotation.ColorAxis<#=sensor.Number#> = colorAxis<#=sensor.Number#>;

            _scatterSeries<#=sensor.Number#> = new ScatterSeries
            {
                MarkerType = MarkerType.Circle,
                MarkerSize = 3,
                MarkerStroke = OxyColor.FromRgb(<#=sensor.Color.R#>, <#=sensor.Color.G#>, <#=sensor.Color.B#>),
                MarkerFill = OxyColors.Transparent,
                Title = "<#=sensor.DisplayName#>",
            };

            PlotModel.Series.Add(_scatterSeries<#=sensor.Number#>);
<#}#>
            PlotModel.Annotations.Add(_fovAnnotation);
            SetupTracksSeries();

            #region Must remain unchanged according to license terms and conditions

            var watermarkAnnotation = GetWatermarkAnnotation();
            PlotModel.Annotations.Add(watermarkAnnotation);

            #endregion Must remain unchanged according to license terms and conditions

            ExistenceProbabilityMin = DefaultExistenceProbabilityMin;
            PredictionTimeSpan = TimeSpan.FromMilliseconds(DefaultPredictionTimeSpan);

            ((IPlotModel)PlotModel).Update(false);
        }

        #region Parameters

<#AddParameters(model.ExportedProperties, "_fovAnnotation", 2);#>

        #endregion

        public PlotModel PlotModel { get; private set; }

        /// <summary>
        /// Gets or sets the minimum existence probability for tracks to be visualized.
        /// </summary>
        /// <remarks>
        /// A track is shown if its existence probability is above this value.
        /// </remarks>
        public double ExistenceProbabilityMin { get; set; }

        /// <summary>
        /// Updates the field of view for all sensors.
        /// </summary>
        /// <remarks>
        /// After calling this method, force the <see cref="PlotModel"/> to redraw, e.g. by
        /// <code>
        /// control.Invoke(new Action(() =>
        /// {
        ///     PlotModel.InvalidatePlot(true);
        /// }));
        /// </code>
        /// </remarks>
        public void UpdateFieldOfView()
        {
            _fovAnnotation.CalculateFOVImage();
        }
<#foreach(var sensor in model.Sensors){#>
        /// <summary>
        /// Sets '<#=sensor.DisplayName#>' measurements.
        /// </summary>
        /// <param name="time">The time of the measurements.</param>
        /// <param name="measurements">The '<#=sensor.DisplayName#>' measurements.</param>
        /// <remarks>
        /// The usage of this method requires the implementation of the method <see cref="MeasurementToSystem<#=sensor.Number#>"/>.
        /// </remarks>
        public void SetMeasurements<#=sensor.Number#>(DateTime time, IEnumerable<<#=sensor.MeasurementSpaceTypeName#>> measurements)
        {
            lock (_itemsLock)
            {
                _measurementsTime<#=sensor.Number#> = time;
                _measurements<#=sensor.Number#> = measurements;
            }
        }

        /// <summary>
        /// Converts a '<#=sensor.DisplayName#>' measurement to system coordinates.
        /// </summary>
        /// <remarks>
        /// <note type="implement">
        /// Add a new file to the project.
        /// In this file, in the namespace '<#=Namespace#>', add the partial class <#=ClassName#>Visualization and implement this partial method.
        /// In the implementation of the partial method, convert the <see cref="measurement"/> to system coordinates and fill the properties
        /// <see cref="CartesianSpace.X"/> and <see cref="CartesianSpace.X"/> of the <see cref="measurementInSystemCoordinates"/> instance.
        /// You may use one of the <see cref="ToSystem"/> methods for this conversion.
        /// The current visualization instance (this) provides properties for all configured parameters, e.g. sensor mounting position.
        /// <example>
        /// <code>
        /// using Baselabs.Statistics.Spaces;
        ///
        /// namespace <#=Namespace#>
        /// {
        ///     partial class <#=ClassName#>Visualization
        ///     {
        ///         partial void MeasurementToSystem<#=sensor.Number#>(<#=sensor.MeasurementSpaceTypeName#> measurement, CartesianSpace measurementInSystemCoordinates)
        ///         {
        ///             ToSystem(measurement, RadarPositionX, RadarPositionY, RadarRotationZ, measurementInSystemCoordinates);
        ///         }
        ///     }
        /// }
        /// </code>
        /// </example>
        /// </note>
        /// </remarks>
        partial void MeasurementToSystem<#=sensor.Number#>(<#=sensor.MeasurementSpaceTypeName#> measurement, CartesianSpace measurementInSystemCoordinates);

        public void SetPredictions<#=sensor.Number#>(
            IEnumerable<<#=ClassName#>.Prediction<<#=model.System.StateSpaceTypeName#>, <#=sensor.MeasurementSpaceTypeName#>>> predictions)
        {
            lock (_itemsLock)
            {
                _predictions<#=sensor.Number#> = predictions;
            }
        }

        public void SetAssociations<#=sensor.Number#>(
            IEnumerable<<#=ClassName#>.Association<<#=sensor.MeasurementSpaceTypeName#>>> associations)
        {
            lock (_itemsLock)
            {
                _associations<#=sensor.Number#> = associations;
            }
        }
<#}#>
        /// <summary>
        /// Gets or sets the time span that is used to predict track positions.
        /// These predicted positions are used to draw driving direction arrows.
        /// </summary>
        public TimeSpan PredictionTimeSpan
        {
            get
            {
                return _trackSeries.PredictionTimeSpan;
            }
            set
            {
                _trackSeries.PredictionTimeSpan = value;
            }
        }

        /// <summary>
        /// Gets or sets the title of the tracks legend entry.
        /// </summary>
        public string TracksLegendTitle
        {
            get
            {
                return _trackSeries.Title;
            }
            set
            {
                if(string.IsNullOrEmpty(value))
                {
                    throw new ArgumentException("The legend title must not be null or empty.");
                }

                _trackSeries.Title = value;

                PlotModel.InvalidatePlot(false);
            }
        }

        /// <summary>
        /// Sets the tracks.
        /// </summary>
        /// <param name="time">The time of the tracks.</param>
        /// <param name="tracks">The tracks.</param>
        public void SetTracks(DateTime time, IEnumerable<GaussianTrack<<#=model.System.StateSpaceTypeName#>>> tracks)
        {
            lock (_itemsLock)
            {
                _tracksTime = time;
                _tracks = tracks;
            }
        }

        /// <summary>
        /// Renders all items.
        /// </summary>
        public void Render()
        {
            UpdateItems();

            PlotModel.InvalidatePlot(false);
        }

        private void InitializeParameters()
        {
            <#InitializeParameters(model.ParameterExpressions, 3);#>
        }

        /// <summary>
        /// Converts the <see cref="measurement"/> to system coordinates.
        /// </summary>
        protected static void ToSystem(IPolarReadOnly measurement, double translationX, double translationY,
            double rotation, CartesianSpace result)
        {
            var cosRotZ = System.Math.Cos(rotation);
            var sinRotZ = System.Math.Sin(rotation);
            var num1 = measurement.Range * System.Math.Cos(measurement.Phi);
            var num2 = measurement.Range * System.Math.Sin(measurement.Phi);
            result.X = num1 * cosRotZ - num2 * sinRotZ + translationX;
            result.Y = num1 * sinRotZ + num2 * cosRotZ + translationY;
        }

        /// <summary>
        /// Converts the <see cref="measurement"/> to system coordinates.
        /// </summary>
        protected static void ToSystem(ICartesian measurement, double translationX, double translationY,
            double rotation, CartesianSpace result)
        {
            var cosRotZ = System.Math.Cos(rotation);
            var sinRotZ = System.Math.Sin(rotation);

            result.X = measurement.X * cosRotZ - measurement.Y * sinRotZ + translationX;
            result.Y = measurement.X * sinRotZ + measurement.Y * cosRotZ + translationY;
        }

        private void UpdateItems()
        {
            DateTime timeTracks;
            IEnumerable<GaussianTrack<<#=model.System.StateSpaceTypeName#>>> tracks;
<#foreach(var sensor in model.Sensors){#>

            DateTime measurementsTime<#=sensor.Number#>;
            IEnumerable<<#=sensor.MeasurementSpaceTypeName#>> measurements<#=sensor.Number#>;

            IEnumerable<<#=ClassName#>.Prediction<<#=model.System.StateSpaceTypeName#>, <#=sensor.MeasurementSpaceTypeName#>>> predictions<#=sensor.Number#>;
            IEnumerable<<#=ClassName#>.Association<<#=sensor.MeasurementSpaceTypeName#>>> associations<#=sensor.Number#>;
<#}#>
            lock (_itemsLock)
            {
                timeTracks = _tracksTime;
                tracks = _tracks;
<#foreach(var sensor in model.Sensors){#>
                measurementsTime<#=sensor.Number#> = _measurementsTime<#=sensor.Number#>;
                measurements<#=sensor.Number#> = _measurements<#=sensor.Number#>;

                predictions<#=sensor.Number#> = _predictions<#=sensor.Number#>;
                associations<#=sensor.Number#> = _associations<#=sensor.Number#>;
<#}#>
            }

            if (tracks != null)
            {
                UpdateTracks(timeTracks, tracks<#foreach(var sensor in model.Sensors){#>, predictions<#=sensor.Number#>, associations<#=sensor.Number#><#}#>);
            }
<#foreach(var sensor in model.Sensors){#>
            if (measurements<#=sensor.Number#> != null)
            {
                UpdateMeasurements<#=sensor.Number#>(measurementsTime<#=sensor.Number#>, measurements<#=sensor.Number#>);
            }
<#}#>
        }

        private void UpdateTracks(
            DateTime time, 
            IEnumerable<GaussianTrack<<#=model.System.StateSpaceTypeName#>>> tracks
            <#foreach(var sensor in model.Sensors){#>, IEnumerable<<#=ClassName#>.Prediction<<#=model.System.StateSpaceTypeName#>, <#=sensor.MeasurementSpaceTypeName#>>> predictions<#=sensor.Number#>, IEnumerable<<#=ClassName#>.Association<<#=sensor.MeasurementSpaceTypeName#>>> associations<#=sensor.Number#><#}#>)
        {
            _trackSeries.Unselect();

            var tracksList = tracks.Where(_ => _.Existence.ExistenceProbability >= ExistenceProbabilityMin)
                .ToList();

            _trackSeries.Points.Clear();

            foreach (var track in tracksList)
            {
                var systemModel = <#CreateModelInstance(model.System, 4);#>

<#foreach(var sensor in model.Sensors){#>

                var prediction<#=sensor.Number#> = predictions<#=sensor.Number#> !=null ? predictions<#=sensor.Number#>.FirstOrDefault(p => p.TrackId == track.ID) : null;
                var predictedState<#=sensor.Number#> = prediction<#=sensor.Number#> != null ? prediction<#=sensor.Number#>.State : null;
                var predictedMeasurement<#=sensor.Number#> = prediction<#=sensor.Number#> != null ? prediction<#=sensor.Number#>.Measurement : null;
<#}#>

                _trackSeries.Points.Add(new TrackPoint(time, track, systemModel)
                {
<#foreach(var sensor in model.Sensors){#>
                    Associations<#=sensor.Number#> = associations<#=sensor.Number#>,
                    PredictedState<#=sensor.Number#> = predictedState<#=sensor.Number#>,
                    PredictedMeasurement<#=sensor.Number#> = predictedMeasurement<#=sensor.Number#>,
<#}#>
                });
            }
        }
<#foreach(var sensor in model.Sensors){#>
        private void UpdateMeasurements<#=sensor.Number#>(DateTime time, IEnumerable<<#=sensor.MeasurementSpaceTypeName#>> measurements)
        {
            _scatterSeries<#=sensor.Number#>.Points.Clear();

            foreach (var measurement in measurements)
            {
                var point = new CartesianSpace {X = double.NaN, Y = double.NaN};

                MeasurementToSystem<#=sensor.Number#>(measurement, point);

                if (double.IsNaN(point.X) || double.IsNaN(point.Y))
                {
                    // The method 'MeasurementToSystem1' is not (correctly) implemented.
                    continue;
                }

                var scatterPoint = new ScatterPoint(point.Y, point.X, value: 1, tag: measurement);
                _scatterSeries<#=sensor.Number#>.Points.Add(scatterPoint);
            }
        }
<#}#>
        private void SetupTracksSeries()
        {
            var colors= Enumerable.Range(0, 360).Select(angle => OxyColor.FromHsv(angle/360.0, 1.0, 1.0));
            const string colorAxisKey = "TrackColor";
            var tracksColorAxis = new LinearColorAxis
            {
                Key = colorAxisKey,
                Palette = new OxyPalette(colors),
                Minimum = 0,
                Maximum = 1,
                Position = AxisPosition.None
            };

            PlotModel.Axes.Add(tracksColorAxis);

            _trackSeries = new TrackSeries(this)
            {
                MarkerType = MarkerType.Diamond,
                MarkerSize = 7,
                MarkerStroke = OxyColors.DarkGreen,
                SelectionMode = SelectionMode.Multiple,
                ColorAxisKey = colorAxisKey,
                Title = "Data Fusion",
            };

            _trackSeries.MouseDown += (sender, args) =>
            {
                if (args.ChangedButton == OxyMouseButton.Left)
                {
                    var track = args.HitTestResult.Item as GaussianTrack<<#=model.System.StateSpaceTypeName#>>;
                    if (track != null)
                    {
                        var clickedItemIndex = (int)System.Math.Round(args.HitTestResult.Index);

                        var selectedItems = _trackSeries.GetSelectedItems();
                        if (selectedItems.Contains(clickedItemIndex))
                        {
                            if (!args.IsControlDown)
                            {
                                _trackSeries.Unselect();
                            }
                            else
                            {
                                _trackSeries.UnselectItem(clickedItemIndex);
                            }
                        }
                        else
                        {
                            if (!args.IsControlDown)
                            {
                                _trackSeries.Unselect();
                            }

                            _trackSeries.SelectItem(clickedItemIndex);
                        }

                        _trackSeries.PlotModel.InvalidatePlot(false);
                    }
                }
            };

            PlotModel.Series.Add(_trackSeries);
        }

        private static OxyPalette CreatePalette(Color color)
        {
            var colors = new OxyColor[100];
            for (int i = 0; i < 100; i++)
            {
                var alpha = (double)i / 100 * 256 / 3.5;
                var oxyColor = OxyColor.FromAColor((byte)alpha, OxyColor.FromRgb(color.R, color.G, color.B));
                colors[i] = oxyColor;
            }
            var palette = new OxyPalette(colors);

            return palette;
        }

        private static LinearColorAxis CreateColorAxis(string colorAxisKey)
        {
            var colorAxis = new LinearColorAxis
            {
                Minimum = 0,
                Maximum = 1,
                Key = colorAxisKey,
            };

            return colorAxis;
        }

        private static PlotModel GetPlotModel(double xMin, double xMax, double yMin, double yMax)
        {
            var model = new PlotModel
            {
                PlotType = PlotType.Cartesian,
                LegendLineSpacing = 2,
                TitleFontWeight = 1.0,
                PlotAreaBorderThickness = new OxyThickness(0.5),
                Background = OxyColors.White,
                SelectionColor = OxyColors.DarkRed
            };

            CreateAxes(xMin, xMax, yMin, yMax, model);

            model.MouseEnter += (sender, args) => SetGridlineStyle(model, true);
            model.MouseLeave += (sender, args) => SetGridlineStyle(model, false);

            return model;
        }

        private static void CreateAxes(double xMin, double xMax, double yMin, double yMax, PlotModel model)
        {
            var yAxis = CreateYAxis(yMin, yMax);
            model.Axes.Add(yAxis);

            var xAxis = CreateXAxis(xMin, xMax);
            model.Axes.Add(xAxis);
        }

        private static void SetGridlineStyle(PlotModel model, bool showDetails)
        {
            var lineStyle = showDetails ? LineStyle.Dot : LineStyle.None;

            var xAxis = model.DefaultXAxis;

            if(xAxis == null)
            {
                return;
            }

            xAxis.MajorGridlineStyle = lineStyle;
            xAxis.MinorGridlineStyle = lineStyle;
            xAxis.MinorTickSize = showDetails ? 4 : 0;

            var yAxis = model.DefaultYAxis;
            yAxis.MajorGridlineStyle = lineStyle;
            yAxis.MinorGridlineStyle = lineStyle;
            yAxis.MinorTickSize = showDetails ? 4 : 0;

            model.InvalidatePlot(false);
        }

        private static LinearAxis CreateXAxis(double xMin, double xMax)
        {
            var axis = new LinearAxis
            {
                Title = "x [m]",
                Minimum = xMin,
                Maximum = xMax,
                Position = AxisPosition.Left,
                TickStyle = TickStyle.Inside,
                MinorTickSize = 0,
            };

            axis.MajorGridlineColor = axis.MinorGridlineColor;

            return axis;
        }

        private static LinearAxis CreateYAxis(double yMin, double yMax)
        {
            var axis = new LinearAxis
            {
                Title = "y [m]",
                Minimum = yMin,
                Maximum = yMax,
                Position = AxisPosition.Bottom,
                StartPosition = 1,
                EndPosition = 0,
                TickStyle = TickStyle.Inside,
                MinorTickSize = 0,
            };

            axis.MajorGridlineColor = axis.MinorGridlineColor;

            return axis;
        }

        #region Must remain unchanged according to license terms and conditions

        private static ImageAnnotation GetWatermarkAnnotation()
        {
            const string baselabsCreateIconResourceName = "Baselabs.Statistics.BASELABS-Create-RGB-grau.png";

            var statisticsAssembly = typeof(Baselabs.Statistics.Spaces.Space).Assembly;

            var manifestResourceStream = statisticsAssembly.GetManifestResourceStream(baselabsCreateIconResourceName);

            if (manifestResourceStream == null)
            {
                throw new InvalidOperationException(
                    string.Format("The resource '{0}' cannot be found in the assembly '{1}'.",
                        baselabsCreateIconResourceName, statisticsAssembly.FullName));
            }

            using (var imageStream = manifestResourceStream)
            {
                var watermarkAnnotation = new ImageAnnotation
                {
                    ImageSource = new OxyImage(imageStream),
                    HorizontalAlignment = OxyPlot.HorizontalAlignment.Left,
                    VerticalAlignment = OxyPlot.VerticalAlignment.Bottom,
                    X = new PlotLength(0, PlotLengthUnit.RelativeToPlotArea),
                    Y = new PlotLength(1, PlotLengthUnit.RelativeToPlotArea),
                    OffsetX = new PlotLength(4, PlotLengthUnit.ScreenUnits),
                    OffsetY = new PlotLength(-4, PlotLengthUnit.ScreenUnits),
                    Height = new PlotLength(32, PlotLengthUnit.ScreenUnits),
                    ToolTip = "Learn more about BASELABS Create",
                    Layer = AnnotationLayer.AboveSeries
                };

                watermarkAnnotation.MouseDown += (sender, args) =>
                {
                    System.Diagnostics.Process.Start("https://www.baselabs.de/create/");
                };

                return watermarkAnnotation;
            }
        }

        #endregion Must remain unchanged according to license terms and conditions

        private class TrackSeries : OxyPlot.Series.ScatterSeries<TrackPoint>
        {
            private const int EllipsePointsCount = 100;
            private static readonly OxyColor EllipseStroke = OxyColors.DarkGreen;
            private static readonly OxyColor EllipseFill = OxyColors.Transparent;
            private const double EllipseStrokeThickness = 1;
            private const double ArrowHeadLength = 6;
            private const double ArrowHeadWidth = 3;
            private const double ArrowStrokeThickness = 1;
            private static readonly OxyColor ArrowColor = OxyColors.DarkGreen;
            private const double ArrowVeeness = 0;

            private readonly <#=ClassName#>Visualization _visualization;

            private readonly Baselabs.Statistics.Tracking.Spaces.CardinalitySpace _zeroCardinality = new Baselabs.Statistics.Tracking.Spaces.CardinalitySpace { Cardinality = 0 };

            public TrackSeries(<#=ClassName#>Visualization visualization)
            {
                _visualization = visualization;
            }

            public override void Render(IRenderContext rc)
            {
                base.Render(rc);

                foreach (var trackPoint in Points)
                {
                    var track = trackPoint.Track;
                    var ellipsePositionX = track.State.Expectation.X;
                    var ellipsePositionY = track.State.Expectation.Y;
                    var ellipseParameters = trackPoint.CovarianceEllipseParameters;

                    RenderEllipse(rc, ellipsePositionX, ellipsePositionY, ellipseParameters);

                    if (PredictionTimeSpan.TotalMilliseconds > 0)
                    {
                        var predictedState = new <#=model.System.StateSpaceTypeName#>();
                        trackPoint.SystemModel.f(track.State.Expectation, PredictionTimeSpan, ref predictedState);

                        RenderArrow(rc, track.State.Expectation, predictedState);
                    }

<#foreach(var sensor in model.Sensors){#>

                    if (trackPoint.Associations<#=sensor.Number#> != null && trackPoint.PredictedState<#=sensor.Number#> != null)
                    {
                        var association =
                            trackPoint.Associations<#=sensor.Number#>.FirstOrDefault(association1 => association1.TrackId == track.ID);

                        if (association != null)
                        {
                            RenderAssociationLine<#=sensor.Number#>(rc, association, trackPoint.PredictedState<#=sensor.Number#>, trackPoint.PredictedMeasurement<#=sensor.Number#>, track);
                        }
                    }
<#}#>
                }
            }
<#foreach(var sensor in model.Sensors){#>

            private void RenderAssociationLine<#=sensor.Number#>(IRenderContext rc,
                <#=ClassName#>.Association<<#=sensor.MeasurementSpaceTypeName#>> association,
                Gaussian<<#=model.System.StateSpaceTypeName#>> predictedState, Gaussian<<#=sensor.MeasurementSpaceTypeName#>> predictedMeasurement, GaussianTrack<<#=model.System.StateSpaceTypeName#>> track)
            {
                var clippingRectangle = GetClippingRect();

                var sensorColor = OxyColor.FromRgb(<#=sensor.Color.R#>, <#=sensor.Color.G#>, <#=sensor.Color.B#>);

                foreach (var hypothesis in association.Hypotheses)
                {
                    ScreenPoint screenPointStart;

                    var measurement = hypothesis.Elements.FirstOrDefault();

                    if (measurement == null) //prediction hypothesis
                    {
                        screenPointStart = Transform(predictedState.Expectation.Y, predictedState.Expectation.X);

                        var detectionModel = <#CreateModelInstance(sensor.DetectionModel, 6, "_visualization");#>
                        detectionModel.GateProbability = <#=sensor.GateProbability#>;

                        var state=predictedState.Expectation;
<#if(!sensor.DetectionModel.DependsOnState){#>
                        detectionModel.Condition = predictedMeasurement.Expectation;
<#}else{#>
                        detectionModel.Condition = state;
<#}#>
                        var detectionProbability = 1 - detectionModel.Evaluate(_zeroCardinality);

                        if(detectionProbability > 0)
                        {
                            rc.DrawMarker(clippingRectangle, screenPointStart, MarkerType.Star, null, GetMarkerSize(hypothesis.Weight), OxyColors.Transparent, sensorColor, 1);
                        }
                    }
                    else
                    {
                        var cartesianSpace = new CartesianSpace {X = double.NaN, Y = double.NaN};
                        _visualization.MeasurementToSystem<#=sensor.Number#>(measurement, cartesianSpace);

                        if(double.IsNaN(cartesianSpace.X) || double.IsNaN(cartesianSpace.Y))
                        {
                            continue;
                        }

                        screenPointStart = Transform(cartesianSpace.Y, cartesianSpace.X);

                        rc.DrawMarker(clippingRectangle, screenPointStart, MarkerType.Circle, null, GetMarkerSize(hypothesis.Weight), sensorColor, sensorColor, 1);
                    }

                    var screenPointEnd = Transform(track.State.Expectation.Y,
                        track.State.Expectation.X);

                    const double minimumSegmentLength = 4;

                    var dashArray = LineStyle.Dot.GetDashArray();
                    
                    rc.DrawClippedLine(
                        clippingRectangle,
                        new[] {screenPointStart, screenPointEnd},
                        minimumSegmentLength * minimumSegmentLength,
                        sensorColor,
                        1,
                        dashArray,
                        LineJoin.Miter,
                        false
                    );
                }
            }
<#}#>
            private double GetMarkerSize(double weight)
            {
                if (weight < 0.3)
                {
                    return 2;
                }
                else if (weight < 0.6)
                {
                    return 3;
                }
                else if (weight < 0.9)
                {
                    return 4;
                }
                else
                {
                    return 5;
                }
            }

            public override void RenderLegend(IRenderContext rc, OxyRect legendBox)
            {
                var xmid = (legendBox.Left + legendBox.Right) / 2;
                var ymid = (legendBox.Top + legendBox.Bottom) / 2;

                var midpt = new ScreenPoint(xmid, ymid);

                rc.DrawMarker(
                    legendBox,
                    midpt,
                    MarkerType,
                    MarkerOutline,
                    MarkerSize,
                    OxyColors.Transparent,
                    MarkerStroke,
                    MarkerStrokeThickness);
            }

            public TimeSpan PredictionTimeSpan { get; set; }

            protected override void UpdateFromDataFields()
            {
                throw new NotImplementedException();
            }

            private void RenderEllipse(IRenderContext rc, double ellipsePositionX, double ellipsePositionY,
                CovarianceEllipseParameters ellipseParameters)
            {
                var clippingRectangle = GetClippingRect();

                var ellipsePoints = GetEllipsePoints(ellipsePositionX, ellipsePositionY, ellipseParameters.MajorSemiAxis,
                    ellipseParameters.MinorSemiAxis, ellipseParameters.Angle);

                var screenPoints = ellipsePoints.Select(Transform).ToList();
                rc.DrawClippedPolygon(clippingRectangle, screenPoints, 4.0, EllipseFill, EllipseStroke, EllipseStrokeThickness,
                    LineStyle.Dot);
            }

            private static IEnumerable<DataPoint> GetEllipsePoints(double x0, double y0, double majorAxisRadius, double minorAxisRadius, double rotation)
            {
                var cosAlpha = System.Math.Cos(rotation);
                var sinAlpha = System.Math.Sin(rotation);

                for (var pointIndex = 0; pointIndex < EllipsePointsCount; ++pointIndex)
                {
                    var angle = pointIndex * 2 * System.Math.PI / ((double)EllipsePointsCount - 1);
                    var cosT = System.Math.Cos(angle);
                    var sinT = System.Math.Sin(angle);
                    var ellipsePointX = x0 + majorAxisRadius * cosT * cosAlpha - minorAxisRadius * sinT * sinAlpha;
                    var ellipsePointY = y0 + majorAxisRadius * cosT * sinAlpha + minorAxisRadius * sinT * cosAlpha;
                    var ellipsePoint = new DataPoint(ellipsePointY, ellipsePointX);
                    yield return ellipsePoint;
                }
            }

            private void RenderArrow(IRenderContext rc, ICartesianReadOnly start, ICartesianReadOnly end)
            {
                var startPoint = new DataPoint(start.Y, start.X);

                var endPoint =new DataPoint(end.Y, end.X);
                var screenEndPoint = Transform(endPoint);

                var screenStartPoint = Transform(startPoint);

                var d = screenEndPoint - screenStartPoint;
                d.Normalize();
                var n = new ScreenVector(d.Y, -d.X);

                var p1 = screenEndPoint - (d * ArrowHeadLength * ArrowStrokeThickness);
                var p2 = p1 + (n * ArrowHeadWidth * ArrowStrokeThickness);
                var p3 = p1 - (n * ArrowHeadWidth * ArrowStrokeThickness);
                var p4 = p1 + (d * ArrowVeeness * ArrowStrokeThickness);

                var clippingRectangle = GetClippingRect();
                const double minimumSegmentLength = 4;

                var dashArray = LineStyle.Solid.GetDashArray();

                rc.DrawClippedLine(
                    clippingRectangle,
                    new[] { screenStartPoint, p4 },
                    minimumSegmentLength * minimumSegmentLength,
                    GetSelectableColor(ArrowColor),
                    ArrowStrokeThickness,
                    dashArray,
                    LineJoin.Miter,
                    false);

                rc.DrawClippedPolygon(
                    clippingRectangle,
                    new[] { p3, screenEndPoint, p2, p4 },
                    minimumSegmentLength * minimumSegmentLength,
                    GetSelectableColor(ArrowColor),
                    OxyColors.Undefined);
            }

            protected virtual double GetEgoVelocity()
            {
                return 0;
            }

            protected virtual double GetEgoYawrate()
            {
                return 0;
            }
        }

        private class TrackPoint : ScatterPoint
        {
            private const int MahalanobisDistance = 6;

            public TrackPoint(DateTime time, GaussianTrack<<#=model.System.StateSpaceTypeName#>> track, <#=model.System.ModelTypeName#> systemModel)
                : base(track.State.Expectation.Y, track.State.Expectation.X, value:GetColorValue(track), tag: track)
            {
                Time = time;
                CovarianceEllipseParameters = track.State.GetCovarianceEllipseParameters(MahalanobisDistance);
                SystemModel = systemModel;
            }

            public DateTime Time { get; private set; }

            public GaussianTrack<<#=model.System.StateSpaceTypeName#>> Track
            {
                get { return (GaussianTrack<<#=model.System.StateSpaceTypeName#>>)Tag; }
            }
<#foreach(var sensor in model.Sensors){#>

            public Gaussian<<#=model.System.StateSpaceTypeName#>> PredictedState<#=sensor.Number#> { get; set; }

            public Gaussian<<#=sensor.MeasurementSpaceTypeName#>> PredictedMeasurement<#=sensor.Number#> { get; set; }

            public IEnumerable<<#=ClassName#>.Association<<#=sensor.MeasurementSpaceTypeName#>>> Associations<#=sensor.Number#> { get; set; }
<#}#>
            public <#=model.System.ModelTypeName#> SystemModel { get; private set; }

            public CovarianceEllipseParameters CovarianceEllipseParameters { get; private set; }

            private static double GetColorValue(GaussianTrack<<#=model.System.StateSpaceTypeName#>> track)
            {
                var random = new Random((int)track.ID);
                var colorValue = random.NextDouble();
                return colorValue;
            }
        }

        private class FieldOfViewAnnotation : Annotation
        {
            private const int CellsYCount = 400;
            private const int CellsXCount = 700;

            private OxyImage _image;

            private double _x0;
            private double _x1;
            private double _y0;
            private double _y1;

            private readonly object _fovImageLock = new object();
<#foreach(var sensor in model.Sensors){#>
            public IColorAxis ColorAxis<#=sensor.Number#> { get; set; }
<#}#>
            #region Parameters

            <#DefineParameters(model.ExportedProperties, 3);#>

            #endregion

            public FieldOfViewAnnotation()
            {
                Layer = AnnotationLayer.BelowAxes;
            }

            public void CalculateFOVImage()
            {
                var m = CellsYCount;
                var n = CellsXCount;

                var x0 = PlotModel.DefaultYAxis.ActualMinimum;
                var x1 = PlotModel.DefaultYAxis.ActualMaximum;
                var y0 = PlotModel.DefaultXAxis.ActualMinimum;
                var y1 = PlotModel.DefaultXAxis.ActualMaximum;

                var newImage = CreateImage(m, n, x0, x1, y0, y1);

                lock (_fovImageLock)
                {
                    _image = newImage;
                    _x0 = x0;
                    _x1 = x1;
                    _y0 = y0;
                    _y1 = y1;
                }
            }

            public override void Render(IRenderContext rc)
            {
                base.Render(rc);

                EnsureAxes();

                OxyImage image = null;
                double bottom;
                double top;
                double left;
                double right;
                lock (_fovImageLock)
                {
                    image = _image;
                    bottom = _x0;
                    top = _x1;
                    left = _y0;
                    right = _y1;
                }

                if (image == null)
                {
                    return;
                }

                var m = CellsYCount;
                var n = CellsXCount;
                var dx = (top - bottom) / (m - 1);
                var dy = (right - left) / (n - 1);

                left -= dx / 2;
                right += dx / 2;

                bottom -= dy / 2;
                top += dy / 2;

                var s00 = Transform(left, bottom);
                var s11 = Transform(right, top);
                var rect = new OxyRect(s00, s11);

                var clip = GetClippingRect();

                rc.DrawClippedImage(clip, image, rect.Left, rect.Top, rect.Width, rect.Height, 1, true);
            }

            private OxyImage CreateImage(int cellsYCount, int cellsXCount, double xMin, double xMax, double yMin, double yMax)
            {
                var reverseX = XAxis.Transform(xMin) > XAxis.Transform(xMax);
                var reverseY = YAxis.Transform(yMin) > YAxis.Transform(yMax);
                var pixels=new OxyColor[cellsYCount, cellsXCount];

<#foreach(var sensor in model.Sensors){#>
                var fov<#=sensor.Number#> = new double[cellsYCount, cellsXCount];
                GetDetectionProbabilities<#=sensor.Number#>(fov<#=sensor.Number#>, xMin, xMax, yMin, yMax);
<#}#>

                for (int i = 0; i < cellsYCount; i++)
                {
                    var ii = reverseX ? cellsYCount - 1 - i : i;
                    for (int j = 0; j < cellsXCount; j++)
                    {
                        var jj = reverseY ? cellsXCount - 1 - j : j;
                        Color result = Color.White;
<#foreach(var sensor in model.Sensors){#>
                        var color<#=sensor.Number#> = ColorAxis<#=sensor.Number#>.GetColor(fov<#=sensor.Number#>[ii, jj]);
                        result = AlphaBlend(color<#=sensor.Number#>, result);
<#}#>
                        pixels[i, j] = OxyColor.FromArgb(result.A, result.R, result.G, result.B);
                    }
                }

                var image = OxyImage.Create(pixels, ImageFormat.Png);

                return image;
            }

            private static Color AlphaBlend(OxyColor source, Color background)
            {
                var sourceAlpha = source.A;
                var backgroundAlpha = background.A;
                var red = MixColorComponent(source.R, sourceAlpha, background.R, backgroundAlpha);
                var green = MixColorComponent(source.G, sourceAlpha, background.G, backgroundAlpha);
                var blue = MixColorComponent(source.B, sourceAlpha, background.B, backgroundAlpha);
                var alpha = MixAlpha(sourceAlpha, backgroundAlpha);
                return Color.FromArgb(alpha, red, green, blue);
            }

            private static byte MixColorComponent(byte source, byte sourceAlpha, byte background, byte backgroundAlpha)
            {
                var mixRatio = 1.0 - sourceAlpha / 255.0;
                return (byte)(source * sourceAlpha / 255.0 + background * backgroundAlpha / 255.0 * mixRatio);
            }

            private static byte MixAlpha(byte sourceAlpha, byte backgroundAlpha)
            {
                return (byte)(sourceAlpha + backgroundAlpha * (1.0 - sourceAlpha / 255.0));
            }
<#foreach(var sensor in model.Sensors){#>
            private void GetDetectionProbabilities<#=sensor.Number#>(double[,] fov, double xMin, double xMax, double yMin, double yMax)
            {
                var detectionModel = <#CreateModelInstance(sensor.DetectionModel, 4);#>
                detectionModel.GateProbability = <#=sensor.GateProbability#>;

<#if(!sensor.DetectionModel.DependsOnState){#>
                var measurementModel = <#CreateModelInstance(sensor.MeasurementModel, 4);#>
                var fieldOfViewProvider = new FieldOfViewProvider<
                    <#=sensor.MeasurementModel.ModelTypeName#>,
                    <#=sensor.DetectionModel.ModelTypeName#>,
                    <#=sensor.MeasurementSpaceTypeName#>,
                    <#=sensor.DetectionModel.DependingSpaceTypeName#>,
                    <#=model.System.StateSpaceTypeName#>>(measurementModel, detectionModel);
<#}else{#>
                var fieldOfViewProvider = new FieldOfViewProvider<<#=sensor.DetectionModel.ModelTypeName#>, <#=model.System.StateSpaceTypeName#>>(detectionModel);
<#}#>
                fieldOfViewProvider.FillFieldOfView(xMin, xMax, yMin, yMax, fov);
            }
<#}#>
            protected virtual double GetEgoVelocity()
            {
                return 0;
            }

            protected virtual double GetEgoYawrate()
            {
                return 0;
            }
        }

        internal class DebounceTimer
        {
            private System.Timers.Timer _timerThreading;

            public void Debounce(TimeSpan interval, Action<object> action,
                object param = null)
            {
                if (_timerThreading != null)
                {
                    _timerThreading.Stop();
                }
                _timerThreading = null;
                _timerThreading = new System.Timers.Timer(interval.TotalMilliseconds) { AutoReset = false };
                _timerThreading.Elapsed += (sender, args) =>
                {
                    if (_timerThreading == null)
                    {
                        return;
                    }
                    if (_timerThreading != null)
                    {
                        _timerThreading.Stop();
                    }
                    _timerThreading = null;
                    action.Invoke(param);
                };
                _timerThreading.Start();
            }
        }

    }

}

namespace <#=Namespace#>.WindowsForms
{
    using System.Windows.Forms;
    using OxyPlot.WindowsForms;
    // Prevents a bug in Mono that does not allow to use the mouse wheel for zooming on Windows.
    // The mouse wheel event arguments deliver screen coordinates instead of widget coordinates.
    internal class WindowsMonoPlotView : PlotView
    {
        protected override void OnMouseWheel(MouseEventArgs e)
        {
            // retrieve window position 
            // this.Parent.Parent == plotView.VisualizationControl.Form
            var x = this.Parent.Parent.Left;
            var y = this.Parent.Parent.Top;
            // widget coordinate = screen.coordinate - window.position
            var xNew = e.X - x;
            var yNew = e.Y - y;
            var eNew = new MouseEventArgs(e.Button, e.Clicks, xNew, yNew, e.Delta);
            base.OnMouseWheel(eNew);
        }
    }
    public partial class <#=ClassName#>VisualizationControl : UserControl
    {
        private readonly <#=ClassName#>Visualization _visualization;
        private readonly TimeSpan _defaultFOVUpdateInterval = TimeSpan.FromMilliseconds(700);
        private readonly <#=ClassName#>Visualization.DebounceTimer _fovTimer = new <#=ClassName#>Visualization.DebounceTimer();
        private Point _rightMouseDownPosition;
        private Point _middleMouseDownPosition;
        private readonly PlotView _plotView;
        private bool _shouldRender;

        public <#=ClassName#>VisualizationControl()
        {
            _visualization = new <#=ClassName#>Visualization();
            _plotView = CreateControl(_visualization);
            Controls.Add(_plotView);

            var renderTimer = new Timer { Interval = 150 };
            renderTimer.Tick += Render;
            renderTimer.Start();
        }

        [System.ComponentModel.DefaultValue("Data Fusion")]
        [System.ComponentModel.DisplayName("Tracks legend title")]
        public string TracksLegendTitle
        {
            get { return _visualization.TracksLegendTitle; }
            set { _visualization.TracksLegendTitle = value; }
        }

        [System.ComponentModel.DefaultValue(<#=ClassName#>Visualization.DefaultExistenceProbabilityMin)]
        [System.ComponentModel.DisplayName("Minimum existence probability")]
        [System.ComponentModel.Description("A track is shown if its existence probability is above this value.")]
        public double ExistenceProbabilityMin
        {
            get { return _visualization.ExistenceProbabilityMin; }
            set { _visualization.ExistenceProbabilityMin = value; }
        }

        [System.ComponentModel.DefaultValue(<#=ClassName#>Visualization.DefaultPredictionTimeSpan)]
        [System.ComponentModel.DisplayName("Prediction time span [ms]")]
        [System.ComponentModel.Description("Predicts tracks to this time to determine the end points of the track direction arrows. Set to 0 to disable track direction arrows.")]
        public int PredictionTimeSpan
        {
            get
            {
                return (int)_visualization.PredictionTimeSpan.TotalMilliseconds;
            }
            set
            {
                _visualization.PredictionTimeSpan = TimeSpan.FromMilliseconds(value);
            }
        }
        <#foreach(var sensor in model.Sensors){#>
        /// <summary>
        /// Sets '<#=sensor.DisplayName#>' measurements.
        /// </summary>
        /// <param name="time">The time of the measurements.</param>
        /// <param name="measurements">The '<#=sensor.DisplayName#>' measurements.</param>
        public void SetMeasurements<#=sensor.Number#>(DateTime time, IEnumerable<<#=sensor.MeasurementSpaceTypeName#>> measurements)
        {
            _visualization.SetMeasurements<#=sensor.Number#>(time, measurements);
            _shouldRender = true;
        }

        public void SetPredictions<#=sensor.Number#>(
            IEnumerable<<#=ClassName#>.Prediction<<#=model.System.StateSpaceTypeName#>, <#=sensor.MeasurementSpaceTypeName#>>> predictions)
        {
            _visualization.SetPredictions<#=sensor.Number#>(predictions);
        }

        public void SetAssociations<#=sensor.Number#>(
            IEnumerable<<#=ClassName#>.Association<<#=sensor.MeasurementSpaceTypeName#>>> associations)
        {
            _visualization.SetAssociations<#=sensor.Number#>(associations);
        }
        <#}#>
        /// <summary>
        /// Sets the tracks.
        /// </summary>
        /// <param name="time">The time of the tracks.</param>
        /// <param name="tracks">The tracks.</param>
        public void SetTracks(DateTime time, IEnumerable<GaussianTrack<<#=model.System.StateSpaceTypeName#>>> tracks)
        {
            _visualization.SetTracks(time, tracks);
            _shouldRender = true;
        }

        private TimeSpan FOVUpdateInterval { get; set; }

        private PlotView CreateControl(<#=ClassName#>Visualization vis)
        {
            FOVUpdateInterval = _defaultFOVUpdateInterval;
            var isWindows = Environment.OSVersion.Platform == PlatformID.Win32NT;
            var isRunningOnMono = (Type.GetType("Mono.Runtime") != null);
            var isWindowsAndMono = (isWindows && isRunningOnMono);

            var plotView = (isWindowsAndMono) ? new WindowsMonoPlotView() : new PlotView() ;
            plotView.Model = vis.PlotModel;
            plotView.Dock = DockStyle.Fill;

            _rightMouseDownPosition = new Point();
            _middleMouseDownPosition = new Point();

            this.HandleCreated += (eventSender, eventArgs) =>
            {
                plotView.MouseWheel += (sender, args) =>
                {
                    UpdateFieldOfView();
                };

                plotView.MouseDown += OnMouseDown;

                plotView.MouseUp += OnMouseUp;

                plotView.SizeChanged += (sender, args) =>
                {
                    UpdateFieldOfView();
                };

                UpdateFieldOfView();

            };

            return plotView;
        }

        private void UpdateFieldOfView()
        {
            _fovTimer.Debounce(FOVUpdateInterval, (p) =>
            {
                _visualization.UpdateFieldOfView();
                if (IsHandleCreated)
                {
                    this.Invoke(new Action(() => _plotView.Model.InvalidatePlot(true)));
                }
            });
        }

        private void Render(object sender, EventArgs e)
        {
            if(!_shouldRender)
            {
                return;
            }

            _visualization.Render();

            _shouldRender = false;
        }

        private void OnMouseDown(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Right)
            {
                _rightMouseDownPosition = e.Location;
            }
            else if (e.Button == MouseButtons.Middle)
            {
                _middleMouseDownPosition = e.Location;
            }
            else if (e.Button == MouseButtons.Left)
            {
            }
        }

        private void OnMouseUp(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Right)
            {
                if (e.Location == _rightMouseDownPosition)
                {
                    return;
                }
            }
            else if (e.Button == MouseButtons.Middle)
            {
                if (e.Location == _middleMouseDownPosition)
                {
                    return;
                }
            }
            else
            {
                return;
            }

            UpdateFieldOfView();
        }
    }

    public partial class <#=ClassName#>VisualizationForm : Form
    {
        public <#=ClassName#>VisualizationForm()
        {
            Control = new <#=ClassName#>VisualizationControl
            {
                Dock = DockStyle.Fill
            };

            Controls.Add(Control);

            #region Must remain unchanged according to license terms and conditions

            Icon = GetBaselabsCreateIcon();

            Load += (sender, args) =>
            {
<#if(string.IsNullOrWhiteSpace(model.DisplayName)){#>
                Text = @"BASELABS Create";
<#}else{#>
                Text = @"BASELABS Create - <#=model.DisplayName#>";
<#}#>
            };

            #endregion Must remain unchanged according to license terms and conditions

            Shown += (sender, args) =>
            {
                var width = Screen.PrimaryScreen.WorkingArea.Width / 3;
                Location = new Point(Screen.PrimaryScreen.WorkingArea.Width - width, 0);
                Width = width;
                Height = Screen.PrimaryScreen.WorkingArea.Height;
            };
        }

        public <#=ClassName#>VisualizationControl Control{ get; private set; }

        #region Must remain unchanged according to license terms and conditions

        private static System.Drawing.Icon GetBaselabsCreateIcon()
        {
            var assembly = typeof(Space).Assembly;
            const string resourceName = "Baselabs.Statistics.BaselabsCreate.png";

            using (var stream = assembly.GetManifestResourceStream(resourceName))
            {
                var image = (Bitmap)Image.FromStream(stream);
                return System.Drawing.Icon.FromHandle(image.GetHicon());
            }
        }

        #endregion Must remain unchanged according to license terms and conditions
    }
}

<#if(AddLinuxVisualization()){#>
namespace <#=Namespace#>.Gtk
{
    using System.Threading;

    public partial class <#=ClassName#>VisualizationPlotView : OxyPlot.GtkSharp.PlotView
    {
        private readonly <#=ClassName#>Visualization _visualization;
        private readonly TimeSpan _defaultFOVUpdateInterval = TimeSpan.FromMilliseconds(700);
        private readonly <#=ClassName#>Visualization.DebounceTimer _fovTimer = new <#=ClassName#>Visualization.DebounceTimer();
        private Point _rightMouseDownPosition;
        private Point _middleMouseDownPosition;
        private bool _shouldRender;
        private Timer _renderTimer;

        public <#=ClassName#>VisualizationPlotView()
        {
            _visualization = new <#=ClassName#>Visualization();
            SetupControl(_visualization);
            _renderTimer = new Timer(state => global::Gtk.Application.Invoke((o, e) => { Render(); }), null, 0, 150);
        }

        [System.ComponentModel.DefaultValue("Data Fusion")]
        [System.ComponentModel.DisplayName("Tracks legend title")]
        public string TracksLegendTitle
        {
            get { return _visualization.TracksLegendTitle; }
            set { _visualization.TracksLegendTitle = value; }
        }

        [System.ComponentModel.DefaultValue(<#=ClassName#>Visualization.DefaultExistenceProbabilityMin)]
        [System.ComponentModel.DisplayName("Minimum existence probability")]
        [System.ComponentModel.Description("A track is shown if its existence probability is above this value.")]
        public double ExistenceProbabilityMin
        {
            get { return _visualization.ExistenceProbabilityMin; }
            set { _visualization.ExistenceProbabilityMin = value; }
        }

        [System.ComponentModel.DefaultValue(<#=ClassName#>Visualization.DefaultPredictionTimeSpan)]
        [System.ComponentModel.DisplayName("Prediction time span [ms]")]
        [System.ComponentModel.Description("Predicts tracks to this time to determine the end points of the track direction arrows. Set to 0 to disable track direction arrows.")]
        public int PredictionTimeSpan
        {
            get
            {
                return (int)_visualization.PredictionTimeSpan.TotalMilliseconds;
            }
            set
            {
                _visualization.PredictionTimeSpan = TimeSpan.FromMilliseconds(value);
            }
        }

        <#foreach(var sensor in model.Sensors){#>

        /// <summary>
        /// Sets '<#=sensor.DisplayName#>' measurements.
        /// </summary>
        /// <param name="time">The time of the measurements.</param>
        /// <param name="measurements">The '<#=sensor.DisplayName#>' measurements.</param>
        public void SetMeasurements<#=sensor.Number#>(DateTime time, IEnumerable<<#=sensor.MeasurementSpaceTypeName#>> measurements)
        {
            _visualization.SetMeasurements<#=sensor.Number#>(time, measurements);
            _shouldRender = true;
        }

        public void SetPredictions<#=sensor.Number#>(
            IEnumerable<<#=ClassName#>.Prediction<<#=model.System.StateSpaceTypeName#>, <#=sensor.MeasurementSpaceTypeName#>>> predictions)
        {
            _visualization.SetPredictions<#=sensor.Number#>(predictions);
        }

        public void SetAssociations<#=sensor.Number#>(
            IEnumerable<<#=ClassName#>.Association<<#=sensor.MeasurementSpaceTypeName#>>> associations)
        {
            _visualization.SetAssociations<#=sensor.Number#>(associations);
        }
        <#}#>

        /// <summary>
        /// Sets the tracks.
        /// </summary>
        /// <param name="time">The time of the tracks.</param>
        /// <param name="tracks">The tracks.</param>
        public void SetTracks(DateTime time, IEnumerable<GaussianTrack<<#=model.System.StateSpaceTypeName#>>> tracks)
        {
            _visualization.SetTracks(time, tracks);
            _shouldRender = true;
        }

        private TimeSpan FOVUpdateInterval { get; set; }

        private void SetupControl(<#=ClassName#>Visualization vis)
        {
            FOVUpdateInterval = _defaultFOVUpdateInterval;

            Events = Gdk.EventMask.AllEventsMask;

            Model = vis.PlotModel;

            _rightMouseDownPosition = new Point();
            _middleMouseDownPosition = new Point();

            UpdateFieldOfView();
        }

        private void UpdateFieldOfView()
        {
            _fovTimer.Debounce(FOVUpdateInterval, (p) =>
            {
                _visualization.UpdateFieldOfView();
                global::Gtk.Application.Invoke((o, e) =>
                {
                    try
                    {
                        Model.InvalidatePlot(true);
                    }
                    catch { }
                });
            });
        }

        private void Render()
        {
            if (!_shouldRender)
            {
                return;
            }

            _visualization.Render();

            _shouldRender = false;
        }

        enum GtkButton : uint
        {
            Left = 1,
            Middle = 2,
            Right = 3
        }

        protected override void OnSizeAllocated(Gdk.Rectangle allocation)
        {
            UpdateFieldOfView();
            base.OnSizeAllocated(allocation);
        }

        protected override bool OnScrollEvent(Gdk.EventScroll e)
        {
            e.Direction = DetermineScrollDirection(e);
            UpdateFieldOfView();
            return base.OnScrollEvent(e);
        }

        protected override bool OnButtonPressEvent(Gdk.EventButton e)
        {
            if ((GtkButton)e.Button == GtkButton.Right)
            {
                _rightMouseDownPosition = GetPoint(e);
            }
            else if ((GtkButton)e.Button == GtkButton.Middle)
            {
                _middleMouseDownPosition = GetPoint(e);
            }
            else if ((GtkButton)e.Button == GtkButton.Left)
            {
            }

            return base.OnButtonPressEvent(e);
        }

        protected override bool OnButtonReleaseEvent(Gdk.EventButton e)
        {
            if ((GtkButton)e.Button == GtkButton.Right)
            {
                if (GetPoint(e) == _rightMouseDownPosition)
                {
                    return base.OnButtonReleaseEvent(e);
                }
            }
            else if ((GtkButton)e.Button == GtkButton.Middle)
            {
                if (GetPoint(e) == _middleMouseDownPosition)
                {
                    return base.OnButtonReleaseEvent(e);
                }
            }
            else
            {
                return base.OnButtonReleaseEvent(e);
            }

            UpdateFieldOfView();

            return base.OnButtonReleaseEvent(e);
        }

        private Point GetPoint(Gdk.EventButton eventButton)
        {
            return new Point((int)eventButton.X, (int)eventButton.Y);
        }

        private Gdk.ScrollDirection DetermineScrollDirection(Gdk.EventScroll e)
        {
            var nativeScrollEvent = (GdkNativeScrollStruct)System.Runtime.InteropServices.Marshal.PtrToStructure(e.Handle, typeof(GdkNativeScrollStruct));
            return nativeScrollEvent.delta_y > 0 ? Gdk.ScrollDirection.Down : Gdk.ScrollDirection.Up;
        }

        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
        struct GdkNativeScrollStruct
        {
            private Gdk.EventType type;
            private IntPtr window;
            private sbyte send_event;
            public uint time;
            public double x;
            public double y;
            public uint state;
            public Gdk.ScrollDirection direction;
            public IntPtr device;
            public double x_root;
            public double y_root;
            public double delta_x;
            public double delta_y;
        }
    }

    public partial class <#=ClassName#>VisualizationWindow : global::Gtk.Window
    {
        public <#=ClassName#>VisualizationWindow() : base(global::Gtk.WindowType.Toplevel)
        {
            Events = Gdk.EventMask.AllEventsMask;
            Control = new <#=ClassName#>VisualizationPlotView();

            var hbox1 = new global::Gtk.HBox
            {
                Events = Gdk.EventMask.AllEventsMask
            };
            hbox1.PackStart(Control, true, true, 0);
            Add(hbox1);

            #region Must remain unchanged according to license terms and conditions

            Icon = GetBaselabsCreateIcon();

            #endregion Must remain unchanged according to license terms and conditions
        }

        public <#=ClassName#>VisualizationPlotView Control { get; private set; }

        protected override void OnShown()
        {
            #region Must remain unchanged according to license terms and conditions

<#if(string.IsNullOrWhiteSpace(model.DisplayName)){#>
            Title = @"BASELABS Create";
<#}else{#>
            Title = @"BASELABS Create - <#=model.DisplayName#>";
<#}#>
            #endregion Must remain unchanged according to license terms and conditions

            var width = Display.DefaultScreen.Width / 3;
            Move(Display.DefaultScreen.Width - width, 0);
            Resize(width, Display.DefaultScreen.Height);

            base.OnShown();
        }

        #region Must remain unchanged according to license terms and conditions

        private static Gdk.Pixbuf GetBaselabsCreateIcon()
        {
            var assembly = typeof(Space).Assembly;
            const string resourceName = "Baselabs.Statistics.BaselabsCreate.png";

            using (var stream = assembly.GetManifestResourceStream(resourceName))
            {
                var pixelBuffer = new Gdk.Pixbuf(stream);
                return pixelBuffer;
            }
        }

        #endregion Must remain unchanged according to license terms and conditions
    }
}<#}#>
namespace <#=Namespace#>
{
    internal partial class <#=ClassName#>VisualizationConnector : IDisposable
    {
        private readonly bool _isWindows = Environment.OSVersion.Platform == PlatformID.Win32NT;
        private WindowsForms.<#=ClassName#>VisualizationForm _form;
<#if(AddLinuxVisualization()){#>
        private Gtk.<#=ClassName#>VisualizationWindow _window;
<#}#><#foreach(var sensor in model.Sensors){#>
        private DateTime _time<#=sensor.Number#>;
<#}#>
        private readonly ManualResetEvent _uiCreatedEvent = new ManualResetEvent(false);

        public <#=ClassName#>VisualizationConnector(<#=ClassName#> dataFusion)
        {
            if(_isWindows)
            {
                new System.Threading.Tasks.Task(ShowForm).Start();
            }
<#if(AddLinuxVisualization()){#>
            else
            {
                new System.Threading.Tasks.Task(ShowWindow).Start();
            }
<#}#>
            _uiCreatedEvent.WaitOne();
            SetupDataFusionCallbacks(dataFusion);
        }

        public void Dispose()
        {
            if(_isWindows)
            {
                InvokeCloseForm();
            }
<#if(AddLinuxVisualization()){#>
            else
            {
                InvokeCloseWindow();
            }
<#}#>
        }

        private void SetTracksWinForms(System.DateTime time, IEnumerable<GaussianTrack<<#=model.System.StateSpaceTypeName#>>> tracks)
        {
            _form.Control.SetTracks(time, tracks);
        }
<#if(AddLinuxVisualization()){#>
        private void SetTracksGtk(System.DateTime time, IEnumerable<GaussianTrack<<#=model.System.StateSpaceTypeName#>>> tracks)
        {
            _window.Control.SetTracks(time, tracks);
        }
<#}#>
<#foreach(var sensor in model.Sensors){#>

        private void SetMeasurementsWinForms<#=sensor.Number#>(System.DateTime time, IEnumerable<<#=sensor.MeasurementSpaceTypeName#>> measurements)
        {
            _form.Control.SetMeasurements<#=sensor.Number#>(time, measurements);
        }

        private void SetPredictionsWinForms<#=sensor.Number#>(IEnumerable<<#=ClassName#>.Prediction<<#=model.System.StateSpaceTypeName#>, <#=sensor.MeasurementSpaceTypeName#>>> predictions)
        {
            _form.Control.SetPredictions<#=sensor.Number#>(predictions);
        }

        private void SetAssociationsWinForms<#=sensor.Number#>(IEnumerable<<#=ClassName#>.Association<<#=sensor.MeasurementSpaceTypeName#>>> associations)
        {
            _form.Control.SetAssociations<#=sensor.Number#>(associations);
        }
<#if(AddLinuxVisualization()){#>
        private void SetMeasurementsGtk<#=sensor.Number#>(System.DateTime time, IEnumerable<<#=sensor.MeasurementSpaceTypeName#>> measurements)
        {
            _window.Control.SetMeasurements<#=sensor.Number#>(time, measurements);
        }

        private void SetPredictionsGtk<#=sensor.Number#>(IEnumerable<<#=ClassName#>.Prediction<<#=model.System.StateSpaceTypeName#>, <#=sensor.MeasurementSpaceTypeName#>>> predictions)
        {
            _window.Control.SetPredictions<#=sensor.Number#>(predictions);
        }

        private void SetAssociationsGtk<#=sensor.Number#>(IEnumerable<<#=ClassName#>.Association<<#=sensor.MeasurementSpaceTypeName#>>> associations)
        {
            _window.Control.SetAssociations<#=sensor.Number#>(associations);
        }
<#}#><#}#>
        private void ShowForm()
        {
            _form = new WindowsForms.<#=ClassName#>VisualizationForm();

            _uiCreatedEvent.Set();

            System.Windows.Forms.Application.Run(_form);
        }

        private void SetupDataFusionCallbacks(<#=ClassName#> dataFusion)
        {
<#foreach(var sensor in model.Sensors){#>

            dataFusion.Processing<#=sensor.Number#> += (time, measurements) =>
            {
                _time<#=sensor.Number#> = time;
                if(_isWindows)
                {
                    SetMeasurementsWinForms<#=sensor.Number#>(time, measurements);
                }
<#if(AddLinuxVisualization()){#>
                else
                {
                    SetMeasurementsGtk<#=sensor.Number#>(time, measurements);
                }
<#}#>
            };

            IEnumerable<<#=ClassName#>.Prediction<<#=model.System.StateSpaceTypeName#>, <#=sensor.MeasurementSpaceTypeName#>>> predictions<#=sensor.Number#> = null;

            dataFusion.Predicted<#=sensor.Number#> += predictions => 
            { 
                predictions<#=sensor.Number#> = predictions;
            };

            IEnumerable<<#=ClassName#>.Association<<#=sensor.MeasurementSpaceTypeName#>>> associations<#=sensor.Number#> = null;

            dataFusion.Associated<#=sensor.Number#> += associations =>
            {
                associations<#=sensor.Number#> = associations;
            };

            dataFusion.Processed<#=sensor.Number#> += () =>
            {
                IEnumerable<GaussianTrack<<#=model.System.StateSpaceTypeName#>>> tracks;
                if(dataFusion.GetTracks(_time<#=sensor.Number#>, out tracks))
                {
                    if(_isWindows)
                    {
                        SetPredictionsWinForms<#=sensor.Number#>(predictions<#=sensor.Number#>); 
                        SetAssociationsWinForms<#=sensor.Number#>(associations<#=sensor.Number#>);
                        SetTracksWinForms(_time<#=sensor.Number#>, tracks);
                    }
<#if(AddLinuxVisualization()){#>
                    else
                    {
                        SetPredictionsGtk<#=sensor.Number#>(predictions<#=sensor.Number#>); 
                        SetAssociationsGtk<#=sensor.Number#>(associations<#=sensor.Number#>);
                        SetTracksGtk(_time<#=sensor.Number#>, tracks);
                    }
<#}#>
                }
            };
<#}#>

        }

        private void InvokeCloseForm()
        {
            if(_form.InvokeRequired)
            {
                _form.Invoke(new Action(CloseForm));
            }
            else
            {
                CloseForm();
            }
        }

        private void CloseForm()
        {
            _form.Close();
        }
<#if(AddLinuxVisualization()){#>
        private void ShowWindow()
        {
            global::Gtk.Application.Init();

            _window = new Gtk.<#=ClassName#>VisualizationWindow();
            _window.ShowAll();

            _uiCreatedEvent.Set();

            global::Gtk.Application.Run();
        }

        private void InvokeCloseWindow()
        {
            global::Gtk.Application.Invoke((o,e)=> { CloseWindow(o,e); });
        }

        private void CloseWindow(object sender, EventArgs e)
        {
            _window.Destroy();
        }<#}#>
    }
}

<#if(AddvADASdeveloperComponent()){#>
namespace <#=Namespace#>.vADASdeveloperComponents
{
    using System.Windows.Forms;
    using Baselabs;
    using Baselabs.ComponentModel;

    public partial class <#=ClassName#>Visualization : Baselabs.ComponentModel.Component
    {
        private Form _form;
        private WindowsForms.<#=ClassName#>VisualizationControl _control;
        private double _existenceProbabilityMin;
        private int _predictionTimeSpan;

        public <#=ClassName#>Visualization()
        {
            ExistenceProbabilityMin = global::<#=FullName#>Visualization.DefaultExistenceProbabilityMin;
            PredictionTimeSpan = global::<#=FullName#>Visualization.DefaultPredictionTimeSpan;

            Initialize();
        }

        /// <summary>
        /// If implemented, this method is called during the initialization of the component.
        /// </summary>
        partial void Initialize();

        public WindowsForms.<#=ClassName#>VisualizationControl Control
        {
            get
            {
                return _control;
            }
            set
            {
                _control = value;

                _control.ExistenceProbabilityMin = _existenceProbabilityMin;
                _control.PredictionTimeSpan = _predictionTimeSpan;
            }
        }

        /// <summary>
        /// If <see cref="Control"/> is not set, creates a stand-alone form that holds the visualization.
        /// </summary>
        protected override void OnActivating()
        {
            base.OnActivating();

            if(Control == null)
            {
                var mainForm = Application.OpenForms[0];

                if (mainForm.InvokeRequired)
                {
                    mainForm.Invoke(new Action(ShowForm));
                }
                else
                {
                    ShowForm();
                }
            }
        }

        public virtual void OnTracks(Context c, Time time, [In("Tracks")] IEnumerable<GaussianTrack<<#=model.System.StateSpaceTypeName#>>> tracks)
        {
            Control.SetTracks(time.UtcTime, tracks);
        }
<#foreach(var sensor in model.Sensors){#>

        public virtual void OnMeasurements<#=sensor.Number#>(Context context, Time time, [In("<#=sensor.DisplayName#> measurements")] IEnumerable<<#=sensor.MeasurementSpaceTypeName#>> measurements)
        {
            Control.SetMeasurements<#=sensor.Number#>(time.UtcTime, measurements);
        }
<#}#>

        private void ShowForm()
        {
            Control = new WindowsForms.<#=ClassName#>VisualizationControl()
            {
                Dock = DockStyle.Fill
            };

            _form = new Form();
            _form.Controls.Add(Control);

            _form.Show();

            var width = Screen.PrimaryScreen.WorkingArea.Width / 4;
            _form.Location = new Point(Screen.PrimaryScreen.WorkingArea.Width - width, 0);
            _form.Width = width;
            _form.Height = Screen.PrimaryScreen.WorkingArea.Height;
        }

        [Settings]
        [System.ComponentModel.DefaultValue(global::<#=FullName#>Visualization.DefaultExistenceProbabilityMin)]
        [System.ComponentModel.DisplayName("Minimum existence probability")]
        [System.ComponentModel.Description("A track is shown if its existence probability is above this value.")]
        public double ExistenceProbabilityMin
        {
            get
            {
                if (Control != null)
                {
                    return Control.ExistenceProbabilityMin;
                }

                return _existenceProbabilityMin;
            }
            set
            {
                if(value < 0 || value>=1)
                {
                    throw new ArgumentOutOfRangeException(
                        "The existence probability should be in the range [0-1).",
                        null as Exception);
                }

                if (Control != null)
                {
                    Control.ExistenceProbabilityMin = value;
                }
                else
                {
                    _existenceProbabilityMin = value;
                }
            }
        }

        [Settings]
        [System.ComponentModel.DefaultValue(global::<#=FullName#>Visualization.DefaultPredictionTimeSpan)]
        [System.ComponentModel.DisplayName("Prediction time span [ms]")]
        [System.ComponentModel.Description("Predicts tracks by this time span to determine the end points of the track direction arrows. Set to 0 to disable track direction arrows.")]
        public int PredictionTimeSpan
        {
            get
            {
                if (Control != null)
                {
                    return Control.PredictionTimeSpan;
                }

                return _predictionTimeSpan;
            }
            set
            {
                if(value < 0)
                {
                    throw new ArgumentOutOfRangeException(
                        "The time span must not be smaller than zero.",
                        null as Exception);
                }

                if (Control != null)
                {
                    Control.PredictionTimeSpan = value;
                }
                else
                {
                    _predictionTimeSpan = value;
                }
            }
        }
    }
}
<#}#>

<#+
    private bool AddvADASdeveloperComponent()
    {
        return ProjectReferencesAssembly("Baselabs.ComponentModel") && ProjectReferencesAssembly("Baselabs.Core");
    }

    private bool AddLinuxVisualization()
    {
        return ProjectReferencesAssembly("gtk-sharp") && ProjectReferencesAssembly("OxyPlot.GtkSharp3");
    }
 #>