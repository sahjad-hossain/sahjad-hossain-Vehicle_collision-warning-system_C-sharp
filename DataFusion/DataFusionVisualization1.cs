// ------------------------------------------------------------------------------
// <auto-generated>
//      This code was generated by BASELABS Create.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
using  System;
using System.Collections.Generic ;
using System.Drawing;
using System.Linq;
using System.Threading;
using Baselabs.Statistics.Distributions;
using Baselabs.Statistics.Spaces;
using Baselabs.Statistics.Tracking.Tracks;
using Baselabs.Statistics.Visualization;
using OxyPlot;
using OxyPlot.Annotations;
using OxyPlot.Axes;
using OxyPlot.Series;
using SelectionMode = OxyPlot.SelectionMode;
using TickStyle = OxyPlot.Axes.TickStyle;

namespace DataFusion
{
    public partial class DataFusion1Visualization
    {
        private readonly FieldOfViewAnnotation _fovAnnotation = new FieldOfViewAnnotation();
        private readonly ScatterSeries _scatterSeries0;
        private readonly ScatterSeries _scatterSeries1;
        private TrackSeries _trackSeries;

        private readonly object _itemsLock = new object();
        private DateTime _measurementsTime0;
        private IEnumerable<RadarSpace> _measurements0;

        private IEnumerable<DataFusion1.Prediction<CVComponentsSpace, RadarSpace>> _predictions0;
        private IEnumerable<DataFusion1.Association<RadarSpace>> _associations0;
        private DateTime _measurementsTime1;
        private IEnumerable<CameraSpace> _measurements1;

        private IEnumerable<DataFusion1.Prediction<CVComponentsSpace, CameraSpace>> _predictions1;
        private IEnumerable<DataFusion1.Association<CameraSpace>> _associations1;
        private DateTime _tracksTime;
        private IEnumerable<GaussianTrack<CVComponentsSpace>> _tracks;

        private const double XMinDefault = -250;
        private const double XMaxDefault = -XMinDefault;
        private const double YMinDefault = -50;
        private const double YMaxDefault = -YMinDefault;

        public const int DefaultPredictionTimeSpan = 1000;
        public const double DefaultExistenceProbabilityMin = 0.99;

        public DataFusion1Visualization()
        {
            InitializeParameters();

            PlotModel = GetPlotModel(XMinDefault, XMaxDefault, YMinDefault, YMaxDefault);
            var palette0 = CreatePalette(Color.FromArgb(137, 176, 28));
            var colorAxis0 = new LinearColorAxis
            {
                Minimum = 0,
                Maximum = 1,
                Palette = palette0,
            };
            PlotModel.Axes.Add(colorAxis0);

            _fovAnnotation.ColorAxis0 = colorAxis0;

            _scatterSeries0 = new ScatterSeries
            {
                MarkerType = MarkerType.Circle,
                MarkerSize = 3,
                MarkerStroke = OxyColor.FromRgb(137, 176, 28),
                MarkerFill = OxyColors.Transparent,
                Title = "RadarSensor",
            };

            PlotModel.Series.Add(_scatterSeries0);
            var palette1 = CreatePalette(Color.FromArgb(245, 156, 0));
            var colorAxis1 = new LinearColorAxis
            {
                Minimum = 0,
                Maximum = 1,
                Palette = palette1,
            };
            PlotModel.Axes.Add(colorAxis1);

            _fovAnnotation.ColorAxis1 = colorAxis1;

            _scatterSeries1 = new ScatterSeries
            {
                MarkerType = MarkerType.Circle,
                MarkerSize = 3,
                MarkerStroke = OxyColor.FromRgb(245, 156, 0),
                MarkerFill = OxyColors.Transparent,
                Title = "CameraSensor",
            };

            PlotModel.Series.Add(_scatterSeries1);
            PlotModel.Annotations.Add(_fovAnnotation);
            SetupTracksSeries();

            #region Must remain unchanged according to license terms and conditions

            var watermarkAnnotation = GetWatermarkAnnotation();
            PlotModel.Annotations.Add(watermarkAnnotation);

            #endregion Must remain unchanged according to license terms and conditions

            ExistenceProbabilityMin = DefaultExistenceProbabilityMin;
            PredictionTimeSpan = TimeSpan.FromMilliseconds(DefaultPredictionTimeSpan);

            ((IPlotModel)PlotModel).Update(false);
        }

        #region Parameters

        
        #region System properties
        
        public System.Double SigmaAccelerationX
        {
            get
            {
                return _fovAnnotation.SigmaAccelerationX;
            }
            set
            {
                _fovAnnotation.SigmaAccelerationX = value;
            }
        }
        
        public System.Double SigmaAccelerationY
        {
            get
            {
                return _fovAnnotation.SigmaAccelerationY;
            }
            set
            {
                _fovAnnotation.SigmaAccelerationY = value;
            }
        }
        
        #endregion System properties
        
        #region RadarSensor measurement model
        
        public System.Double SensorPositionX
        {
            get
            {
                return _fovAnnotation.SensorPositionX;
            }
            set
            {
                _fovAnnotation.SensorPositionX = value;
            }
        }
        
        public System.Double SensorPositionY
        {
            get
            {
                return _fovAnnotation.SensorPositionY;
            }
            set
            {
                _fovAnnotation.SensorPositionY = value;
            }
        }
        
        public System.Double SensorRotationZ
        {
            get
            {
                return _fovAnnotation.SensorRotationZ;
            }
            set
            {
                _fovAnnotation.SensorRotationZ = value;
            }
        }
        
        public System.Double SigmaAzimuth
        {
            get
            {
                return _fovAnnotation.SigmaAzimuth;
            }
            set
            {
                _fovAnnotation.SigmaAzimuth = value;
            }
        }
        
        public System.Double SigmaRange
        {
            get
            {
                return _fovAnnotation.SigmaRange;
            }
            set
            {
                _fovAnnotation.SigmaRange = value;
            }
        }
        
        public System.Double SigmaRangeRate
        {
            get
            {
                return _fovAnnotation.SigmaRangeRate;
            }
            set
            {
                _fovAnnotation.SigmaRangeRate = value;
            }
        }
        
        #endregion RadarSensor measurement model
        
        #region RadarSensor detection model
        
        public System.Double DetectionAngleMax
        {
            get
            {
                return _fovAnnotation.DetectionAngleMax;
            }
            set
            {
                _fovAnnotation.DetectionAngleMax = value;
            }
        }
        
        public System.Double DetectionAngleMin
        {
            get
            {
                return _fovAnnotation.DetectionAngleMin;
            }
            set
            {
                _fovAnnotation.DetectionAngleMin = value;
            }
        }
        
        public System.Double DetectionRangeMax
        {
            get
            {
                return _fovAnnotation.DetectionRangeMax;
            }
            set
            {
                _fovAnnotation.DetectionRangeMax = value;
            }
        }
        
        public System.Double DetectionRangeMin
        {
            get
            {
                return _fovAnnotation.DetectionRangeMin;
            }
            set
            {
                _fovAnnotation.DetectionRangeMin = value;
            }
        }
        
        #endregion RadarSensor detection model
        
        #region RadarSensor track proposer
        
        public System.Double SigmaVx
        {
            get
            {
                return _fovAnnotation.SigmaVx;
            }
            set
            {
                _fovAnnotation.SigmaVx = value;
            }
        }
        
        public System.Double SigmaVy
        {
            get
            {
                return _fovAnnotation.SigmaVy;
            }
            set
            {
                _fovAnnotation.SigmaVy = value;
            }
        }
        
        public System.Double SigmaX
        {
            get
            {
                return _fovAnnotation.SigmaX;
            }
            set
            {
                _fovAnnotation.SigmaX = value;
            }
        }
        
        public System.Double SigmaY
        {
            get
            {
                return _fovAnnotation.SigmaY;
            }
            set
            {
                _fovAnnotation.SigmaY = value;
            }
        }
        
        public System.Double InitialExistenceProbability
        {
            get
            {
                return _fovAnnotation.InitialExistenceProbability;
            }
            set
            {
                _fovAnnotation.InitialExistenceProbability = value;
            }
        }
        
        #endregion RadarSensor track proposer
        
        #region CameraSensor measurement model
        
        public System.Double SigmaColumn
        {
            get
            {
                return _fovAnnotation.SigmaColumn;
            }
            set
            {
                _fovAnnotation.SigmaColumn = value;
            }
        }
        
        public System.Double SigmaRow
        {
            get
            {
                return _fovAnnotation.SigmaRow;
            }
            set
            {
                _fovAnnotation.SigmaRow = value;
            }
        }
        
        #endregion CameraSensor measurement model
        
        #region Track removers
        
        public System.Double MinimumExistenceProbability
        {
            get
            {
                return _fovAnnotation.MinimumExistenceProbability;
            }
            set
            {
                _fovAnnotation.MinimumExistenceProbability = value;
            }
        }
        
        #endregion Track removers

        #endregion

        public PlotModel PlotModel { get; private set; }

        /// <summary>
        /// Gets or sets the minimum existence probability for tracks to be visualized.
        /// </summary>
        /// <remarks>
        /// A track is shown if its existence probability is above this value.
        /// </remarks>
        public double ExistenceProbabilityMin { get; set; }

        /// <summary>
        /// Updates the field of view for all sensors.
        /// </summary>
        /// <remarks>
        /// After calling this method, force the <see cref="PlotModel"/> to redraw, e.g. by
        /// <code>
        /// control.Invoke(new Action(() =>
        /// {
        ///     PlotModel.InvalidatePlot(true);
        /// }));
        /// </code>
        /// </remarks>
        public void UpdateFieldOfView()
        {
            _fovAnnotation.CalculateFOVImage();
        }
        /// <summary>
        /// Sets 'RadarSensor' measurements.
        /// </summary>
        /// <param name="time">The time of the measurements.</param>
        /// <param name="measurements">The 'RadarSensor' measurements.</param>
        /// <remarks>
        /// The usage of this method requires the implementation of the method <see cref="MeasurementToSystem0"/>.
        /// </remarks>
        public void SetMeasurements0(DateTime time, IEnumerable<RadarSpace> measurements)
        {
            lock (_itemsLock)
            {
                _measurementsTime0 = time;
                _measurements0 = measurements;
            }
        }

        /// <summary>
        /// Converts a 'RadarSensor' measurement to system coordinates.
        /// </summary>
        /// <remarks>
        /// <note type="implement">
        /// Add a new file to the project.
        /// In this file, in the namespace 'DataFusion', add the partial class DataFusion1Visualization and implement this partial method.
        /// In the implementation of the partial method, convert the <see cref="measurement"/> to system coordinates and fill the properties
        /// <see cref="CartesianSpace.X"/> and <see cref="CartesianSpace.X"/> of the <see cref="measurementInSystemCoordinates"/> instance.
        /// You may use one of the <see cref="ToSystem"/> methods for this conversion.
        /// The current visualization instance (this) provides properties for all configured parameters, e.g. sensor mounting position.
        /// <example>
        /// <code>
        /// using Baselabs.Statistics.Spaces;
        ///
        /// namespace DataFusion
        /// {
        ///     partial class DataFusion1Visualization
        ///     {
        ///         partial void MeasurementToSystem0(RadarSpace measurement, CartesianSpace measurementInSystemCoordinates)
        ///         {
        ///             ToSystem(measurement, RadarPositionX, RadarPositionY, RadarRotationZ, measurementInSystemCoordinates);
        ///         }
        ///     }
        /// }
        /// </code>
        /// </example>
        /// </note>
        /// </remarks>
        partial void MeasurementToSystem0(RadarSpace measurement, CartesianSpace measurementInSystemCoordinates);

        public void SetPredictions0(
            IEnumerable<DataFusion1.Prediction<CVComponentsSpace, RadarSpace>> predictions)
        {
            lock (_itemsLock)
            {
                _predictions0 = predictions;
            }
        }

        public void SetAssociations0(
            IEnumerable<DataFusion1.Association<RadarSpace>> associations)
        {
            lock (_itemsLock)
            {
                _associations0 = associations;
            }
        }
        /// <summary>
        /// Sets 'CameraSensor' measurements.
        /// </summary>
        /// <param name="time">The time of the measurements.</param>
        /// <param name="measurements">The 'CameraSensor' measurements.</param>
        /// <remarks>
        /// The usage of this method requires the implementation of the method <see cref="MeasurementToSystem1"/>.
        /// </remarks>
        public void SetMeasurements1(DateTime time, IEnumerable<CameraSpace> measurements)
        {
            lock (_itemsLock)
            {
                _measurementsTime1 = time;
                _measurements1 = measurements;
            }
        }

        /// <summary>
        /// Converts a 'CameraSensor' measurement to system coordinates.
        /// </summary>
        /// <remarks>
        /// <note type="implement">
        /// Add a new file to the project.
        /// In this file, in the namespace 'DataFusion', add the partial class DataFusion1Visualization and implement this partial method.
        /// In the implementation of the partial method, convert the <see cref="measurement"/> to system coordinates and fill the properties
        /// <see cref="CartesianSpace.X"/> and <see cref="CartesianSpace.X"/> of the <see cref="measurementInSystemCoordinates"/> instance.
        /// You may use one of the <see cref="ToSystem"/> methods for this conversion.
        /// The current visualization instance (this) provides properties for all configured parameters, e.g. sensor mounting position.
        /// <example>
        /// <code>
        /// using Baselabs.Statistics.Spaces;
        ///
        /// namespace DataFusion
        /// {
        ///     partial class DataFusion1Visualization
        ///     {
        ///         partial void MeasurementToSystem1(CameraSpace measurement, CartesianSpace measurementInSystemCoordinates)
        ///         {
        ///             ToSystem(measurement, RadarPositionX, RadarPositionY, RadarRotationZ, measurementInSystemCoordinates);
        ///         }
        ///     }
        /// }
        /// </code>
        /// </example>
        /// </note>
        /// </remarks>
        partial void MeasurementToSystem1(CameraSpace measurement, CartesianSpace measurementInSystemCoordinates);

        public void SetPredictions1(
            IEnumerable<DataFusion1.Prediction<CVComponentsSpace, CameraSpace>> predictions)
        {
            lock (_itemsLock)
            {
                _predictions1 = predictions;
            }
        }

        public void SetAssociations1(
            IEnumerable<DataFusion1.Association<CameraSpace>> associations)
        {
            lock (_itemsLock)
            {
                _associations1 = associations;
            }
        }
        /// <summary>
        /// Gets or sets the time span that is used to predict track positions.
        /// These predicted positions are used to draw driving direction arrows.
        /// </summary>
        public TimeSpan PredictionTimeSpan
        {
            get
            {
                return _trackSeries.PredictionTimeSpan;
            }
            set
            {
                _trackSeries.PredictionTimeSpan = value;
            }
        }

        /// <summary>
        /// Gets or sets the title of the tracks legend entry.
        /// </summary>
        public string TracksLegendTitle
        {
            get
            {
                return _trackSeries.Title;
            }
            set
            {
                if(string.IsNullOrEmpty(value))
                {
                    throw new ArgumentException("The legend title must not be null or empty.");
                }

                _trackSeries.Title = value;

                PlotModel.InvalidatePlot(false);
            }
        }

        /// <summary>
        /// Sets the tracks.
        /// </summary>
        /// <param name="time">The time of the tracks.</param>
        /// <param name="tracks">The tracks.</param>
        public void SetTracks(DateTime time, IEnumerable<GaussianTrack<CVComponentsSpace>> tracks)
        {
            lock (_itemsLock)
            {
                _tracksTime = time;
                _tracks = tracks;
            }
        }

        /// <summary>
        /// Renders all items.
        /// </summary>
        public void Render()
        {
            UpdateItems();

            PlotModel.InvalidatePlot(false);
        }

        private void InitializeParameters()
        {
            this.SigmaAccelerationX = 2D;
            
            this.SigmaAccelerationY = 2D;
            
            this.SensorPositionX = 3.55D;
            
            this.SensorPositionY = 0D;
            
            this.SensorRotationZ = 0D;
            
            this.SigmaAzimuth = 0.01D;
            
            this.SigmaRange = 1.2D;
            
            this.SigmaRangeRate = 0.45D;
            
            this.DetectionAngleMax = 0.16D;
            
            this.DetectionAngleMin = -0.16D;
            
            this.DetectionRangeMax = 200D;
            
            this.DetectionRangeMin = 1D;
            
            this.SigmaVx = 1.4D;
            
            this.SigmaVy = 1.2D;
            
            this.SigmaX = 1D;
            
            this.SigmaY = 1D;
            
            this.InitialExistenceProbability = 0.8D;
            
            this.SigmaColumn = 6D;
            
            this.SigmaRow = 6D;
            
            this.MinimumExistenceProbability = 0.1D;
            
        }

        /// <summary>
        /// Converts the <see cref="measurement"/> to system coordinates.
        /// </summary>
        protected static void ToSystem(IPolarReadOnly measurement, double translationX, double translationY,
            double rotation, CartesianSpace result)
        {
            var cosRotZ = System.Math.Cos(rotation);
            var sinRotZ = System.Math.Sin(rotation);
            var num1 = measurement.Range * System.Math.Cos(measurement.Phi);
            var num2 = measurement.Range * System.Math.Sin(measurement.Phi);
            result.X = num1 * cosRotZ - num2 * sinRotZ + translationX;
            result.Y = num1 * sinRotZ + num2 * cosRotZ + translationY;
        }

        /// <summary>
        /// Converts the <see cref="measurement"/> to system coordinates.
        /// </summary>
        protected static void ToSystem(ICartesian measurement, double translationX, double translationY,
            double rotation, CartesianSpace result)
        {
            var cosRotZ = System.Math.Cos(rotation);
            var sinRotZ = System.Math.Sin(rotation);

            result.X = measurement.X * cosRotZ - measurement.Y * sinRotZ + translationX;
            result.Y = measurement.X * sinRotZ + measurement.Y * cosRotZ + translationY;
        }

        private void UpdateItems()
        {
            DateTime timeTracks;
            IEnumerable<GaussianTrack<CVComponentsSpace>> tracks;

            DateTime measurementsTime0;
            IEnumerable<RadarSpace> measurements0;

            IEnumerable<DataFusion1.Prediction<CVComponentsSpace, RadarSpace>> predictions0;
            IEnumerable<DataFusion1.Association<RadarSpace>> associations0;

            DateTime measurementsTime1;
            IEnumerable<CameraSpace> measurements1;

            IEnumerable<DataFusion1.Prediction<CVComponentsSpace, CameraSpace>> predictions1;
            IEnumerable<DataFusion1.Association<CameraSpace>> associations1;
            lock (_itemsLock)
            {
                timeTracks = _tracksTime;
                tracks = _tracks;
                measurementsTime0 = _measurementsTime0;
                measurements0 = _measurements0;

                predictions0 = _predictions0;
                associations0 = _associations0;
                measurementsTime1 = _measurementsTime1;
                measurements1 = _measurements1;

                predictions1 = _predictions1;
                associations1 = _associations1;
            }

            if (tracks != null)
            {
                UpdateTracks(timeTracks, tracks, predictions0, associations0, predictions1, associations1);
            }
            if (measurements0 != null)
            {
                UpdateMeasurements0(measurementsTime0, measurements0);
            }
            if (measurements1 != null)
            {
                UpdateMeasurements1(measurementsTime1, measurements1);
            }
        }

        private void UpdateTracks(
            DateTime time, 
            IEnumerable<GaussianTrack<CVComponentsSpace>> tracks
            , IEnumerable<DataFusion1.Prediction<CVComponentsSpace, RadarSpace>> predictions0, IEnumerable<DataFusion1.Association<RadarSpace>> associations0, IEnumerable<DataFusion1.Prediction<CVComponentsSpace, CameraSpace>> predictions1, IEnumerable<DataFusion1.Association<CameraSpace>> associations1)
        {
            _trackSeries.Unselect();

            var tracksList = tracks.Where(_ => _.Existence.ExistenceProbability >= ExistenceProbabilityMin)
                .ToList();

            _trackSeries.Points.Clear();

            foreach (var track in tracksList)
            {
                var systemModel = new DataFusion.CVVectorialModel()
                {
                    SigmaAccelerationX = this.SigmaAccelerationX,
                    SigmaAccelerationY = this.SigmaAccelerationY,
                };


                var prediction0 = predictions0 !=null ? predictions0.FirstOrDefault(p => p.TrackId == track.ID) : null;
                var predictedState0 = prediction0 != null ? prediction0.State : null;
                var predictedMeasurement0 = prediction0 != null ? prediction0.Measurement : null;

                var prediction1 = predictions1 !=null ? predictions1.FirstOrDefault(p => p.TrackId == track.ID) : null;
                var predictedState1 = prediction1 != null ? prediction1.State : null;
                var predictedMeasurement1 = prediction1 != null ? prediction1.Measurement : null;

                _trackSeries.Points.Add(new TrackPoint(time, track, systemModel)
                {
                    Associations0 = associations0,
                    PredictedState0 = predictedState0,
                    PredictedMeasurement0 = predictedMeasurement0,
                    Associations1 = associations1,
                    PredictedState1 = predictedState1,
                    PredictedMeasurement1 = predictedMeasurement1,
                });
            }
        }
        private void UpdateMeasurements0(DateTime time, IEnumerable<RadarSpace> measurements)
        {
            _scatterSeries0.Points.Clear();

            foreach (var measurement in measurements)
            {
                var point = new CartesianSpace {X = double.NaN, Y = double.NaN};

                MeasurementToSystem0(measurement, point);

                if (double.IsNaN(point.X) || double.IsNaN(point.Y))
                {
                    // The method 'MeasurementToSystem1' is not (correctly) implemented.
                    continue;
                }

                var scatterPoint = new ScatterPoint(point.Y, point.X, value: 1, tag: measurement);
                _scatterSeries0.Points.Add(scatterPoint);
            }
        }
        private void UpdateMeasurements1(DateTime time, IEnumerable<CameraSpace> measurements)
        {
            _scatterSeries1.Points.Clear();

            foreach (var measurement in measurements)
            {
                var point = new CartesianSpace {X = double.NaN, Y = double.NaN};

                MeasurementToSystem1(measurement, point);

                if (double.IsNaN(point.X) || double.IsNaN(point.Y))
                {
                    // The method 'MeasurementToSystem1' is not (correctly) implemented.
                    continue;
                }

                var scatterPoint = new ScatterPoint(point.Y, point.X, value: 1, tag: measurement);
                _scatterSeries1.Points.Add(scatterPoint);
            }
        }
        private void SetupTracksSeries()
        {
            var colors= Enumerable.Range(0, 360).Select(angle => OxyColor.FromHsv(angle/360.0, 1.0, 1.0));
            const string colorAxisKey = "TrackColor";
            var tracksColorAxis = new LinearColorAxis
            {
                Key = colorAxisKey,
                Palette = new OxyPalette(colors),
                Minimum = 0,
                Maximum = 1,
                Position = AxisPosition.None
            };

            PlotModel.Axes.Add(tracksColorAxis);

            _trackSeries = new TrackSeries(this)
            {
                MarkerType = MarkerType.Diamond,
                MarkerSize = 7,
                MarkerStroke = OxyColors.DarkGreen,
                SelectionMode = SelectionMode.Multiple,
                ColorAxisKey = colorAxisKey,
                Title = "Data Fusion",
            };

            _trackSeries.MouseDown += (sender, args) =>
            {
                if (args.ChangedButton == OxyMouseButton.Left)
                {
                    var track = args.HitTestResult.Item as GaussianTrack<CVComponentsSpace>;
                    if (track != null)
                    {
                        var clickedItemIndex = (int)System.Math.Round(args.HitTestResult.Index);

                        var selectedItems = _trackSeries.GetSelectedItems();
                        if (selectedItems.Contains(clickedItemIndex))
                        {
                            if (!args.IsControlDown)
                            {
                                _trackSeries.Unselect();
                            }
                            else
                            {
                                _trackSeries.UnselectItem(clickedItemIndex);
                            }
                        }
                        else
                        {
                            if (!args.IsControlDown)
                            {
                                _trackSeries.Unselect();
                            }

                            _trackSeries.SelectItem(clickedItemIndex);
                        }

                        _trackSeries.PlotModel.InvalidatePlot(false);
                    }
                }
            };

            PlotModel.Series.Add(_trackSeries);
        }

        private static OxyPalette CreatePalette(Color color)
        {
            var colors = new OxyColor[100];
            for (int i = 0; i < 100; i++)
            {
                var alpha = (double)i / 100 * 256 / 3.5;
                var oxyColor = OxyColor.FromAColor((byte)alpha, OxyColor.FromRgb(color.R, color.G, color.B));
                colors[i] = oxyColor;
            }
            var palette = new OxyPalette(colors);

            return palette;
        }

        private static LinearColorAxis CreateColorAxis(string colorAxisKey)
        {
            var colorAxis = new LinearColorAxis
            {
                Minimum = 0,
                Maximum = 1,
                Key = colorAxisKey,
            };

            return colorAxis;
        }

        private static PlotModel GetPlotModel(double xMin, double xMax, double yMin, double yMax)
        {
            var model = new PlotModel
            {
                PlotType = PlotType.Cartesian,
                LegendLineSpacing = 2,
                TitleFontWeight = 1.0,
                PlotAreaBorderThickness = new OxyThickness(0.5),
                Background = OxyColors.White,
                SelectionColor = OxyColors.DarkRed
            };

            CreateAxes(xMin, xMax, yMin, yMax, model);

            model.MouseEnter += (sender, args) => SetGridlineStyle(model, true);
            model.MouseLeave += (sender, args) => SetGridlineStyle(model, false);

            return model;
        }

        private static void CreateAxes(double xMin, double xMax, double yMin, double yMax, PlotModel model)
        {
            var yAxis = CreateYAxis(yMin, yMax);
            model.Axes.Add(yAxis);

            var xAxis = CreateXAxis(xMin, xMax);
            model.Axes.Add(xAxis);
        }

        private static void SetGridlineStyle(PlotModel model, bool showDetails)
        {
            var lineStyle = showDetails ? LineStyle.Dot : LineStyle.None;

            var xAxis = model.DefaultXAxis;

            if(xAxis == null)
            {
                return;
            }

            xAxis.MajorGridlineStyle = lineStyle;
            xAxis.MinorGridlineStyle = lineStyle;
            xAxis.MinorTickSize = showDetails ? 4 : 0;

            var yAxis = model.DefaultYAxis;
            yAxis.MajorGridlineStyle = lineStyle;
            yAxis.MinorGridlineStyle = lineStyle;
            yAxis.MinorTickSize = showDetails ? 4 : 0;

            model.InvalidatePlot(false);
        }

        private static LinearAxis CreateXAxis(double xMin, double xMax)
        {
            var axis = new LinearAxis
            {
                Title = "x [m]",
                Minimum = xMin,
                Maximum = xMax,
                Position = AxisPosition.Left,
                TickStyle = TickStyle.Inside,
                MinorTickSize = 0,
            };

            axis.MajorGridlineColor = axis.MinorGridlineColor;

            return axis;
        }

        private static LinearAxis CreateYAxis(double yMin, double yMax)
        {
            var axis = new LinearAxis
            {
                Title = "y [m]",
                Minimum = yMin,
                Maximum = yMax,
                Position = AxisPosition.Bottom,
                StartPosition = 1,
                EndPosition = 0,
                TickStyle = TickStyle.Inside,
                MinorTickSize = 0,
            };

            axis.MajorGridlineColor = axis.MinorGridlineColor;

            return axis;
        }

        #region Must remain unchanged according to license terms and conditions

        private static ImageAnnotation GetWatermarkAnnotation()
        {
            const string baselabsCreateIconResourceName = "Baselabs.Statistics.BASELABS-Create-RGB-grau.png";

            var statisticsAssembly = typeof(Baselabs.Statistics.Spaces.Space).Assembly;

            var manifestResourceStream = statisticsAssembly.GetManifestResourceStream(baselabsCreateIconResourceName);

            if (manifestResourceStream == null)
            {
                throw new InvalidOperationException(
                    string.Format("The resource '{0}' cannot be found in the assembly '{1}'.",
                        baselabsCreateIconResourceName, statisticsAssembly.FullName));
            }

            using (var imageStream = manifestResourceStream)
            {
                var watermarkAnnotation = new ImageAnnotation
                {
                    ImageSource = new OxyImage(imageStream),
                    HorizontalAlignment = OxyPlot.HorizontalAlignment.Left,
                    VerticalAlignment = OxyPlot.VerticalAlignment.Bottom,
                    X = new PlotLength(0, PlotLengthUnit.RelativeToPlotArea),
                    Y = new PlotLength(1, PlotLengthUnit.RelativeToPlotArea),
                    OffsetX = new PlotLength(4, PlotLengthUnit.ScreenUnits),
                    OffsetY = new PlotLength(-4, PlotLengthUnit.ScreenUnits),
                    Height = new PlotLength(32, PlotLengthUnit.ScreenUnits),
                    ToolTip = "Learn more about BASELABS Create",
                    Layer = AnnotationLayer.AboveSeries
                };

                watermarkAnnotation.MouseDown += (sender, args) =>
                {
                    System.Diagnostics.Process.Start("https://www.baselabs.de/create/");
                };

                return watermarkAnnotation;
            }
        }

        #endregion Must remain unchanged according to license terms and conditions

        private class TrackSeries : OxyPlot.Series.ScatterSeries<TrackPoint>
        {
            private const int EllipsePointsCount = 100;
            private static readonly OxyColor EllipseStroke = OxyColors.DarkGreen;
            private static readonly OxyColor EllipseFill = OxyColors.Transparent;
            private const double EllipseStrokeThickness = 1;
            private const double ArrowHeadLength = 6;
            private const double ArrowHeadWidth = 3;
            private const double ArrowStrokeThickness = 1;
            private static readonly OxyColor ArrowColor = OxyColors.DarkGreen;
            private const double ArrowVeeness = 0;

            private readonly DataFusion1Visualization _visualization;

            private readonly Baselabs.Statistics.Tracking.Spaces.CardinalitySpace _zeroCardinality = new Baselabs.Statistics.Tracking.Spaces.CardinalitySpace { Cardinality = 0 };

            public TrackSeries(DataFusion1Visualization visualization)
            {
                _visualization = visualization;
            }

            public override void Render(IRenderContext rc)
            {
                base.Render(rc);

                foreach (var trackPoint in Points)
                {
                    var track = trackPoint.Track;
                    var ellipsePositionX = track.State.Expectation.X;
                    var ellipsePositionY = track.State.Expectation.Y;
                    var ellipseParameters = trackPoint.CovarianceEllipseParameters;

                    RenderEllipse(rc, ellipsePositionX, ellipsePositionY, ellipseParameters);

                    if (PredictionTimeSpan.TotalMilliseconds > 0)
                    {
                        var predictedState = new CVComponentsSpace();
                        trackPoint.SystemModel.f(track.State.Expectation, PredictionTimeSpan, ref predictedState);

                        RenderArrow(rc, track.State.Expectation, predictedState);
                    }


                    if (trackPoint.Associations0 != null && trackPoint.PredictedState0 != null)
                    {
                        var association =
                            trackPoint.Associations0.FirstOrDefault(association1 => association1.TrackId == track.ID);

                        if (association != null)
                        {
                            RenderAssociationLine0(rc, association, trackPoint.PredictedState0, trackPoint.PredictedMeasurement0, track);
                        }
                    }

                    if (trackPoint.Associations1 != null && trackPoint.PredictedState1 != null)
                    {
                        var association =
                            trackPoint.Associations1.FirstOrDefault(association1 => association1.TrackId == track.ID);

                        if (association != null)
                        {
                            RenderAssociationLine1(rc, association, trackPoint.PredictedState1, trackPoint.PredictedMeasurement1, track);
                        }
                    }
                }
            }

            private void RenderAssociationLine0(IRenderContext rc,
                DataFusion1.Association<RadarSpace> association,
                Gaussian<CVComponentsSpace> predictedState, Gaussian<RadarSpace> predictedMeasurement, GaussianTrack<CVComponentsSpace> track)
            {
                var clippingRectangle = GetClippingRect();

                var sensorColor = OxyColor.FromRgb(137, 176, 28);

                foreach (var hypothesis in association.Hypotheses)
                {
                    ScreenPoint screenPointStart;

                    var measurement = hypothesis.Elements.FirstOrDefault();

                    if (measurement == null) //prediction hypothesis
                    {
                        screenPointStart = Transform(predictedState.Expectation.Y, predictedState.Expectation.X);

                        var detectionModel = new DataFusion.RadarDetectionModel()
                        {
                            DetectionAngleMax = _visualization.DetectionAngleMax,
                            DetectionAngleMin = _visualization.DetectionAngleMin,
                            DetectionRangeMax = _visualization.DetectionRangeMax,
                            DetectionRangeMin = _visualization.DetectionRangeMin,
                        };
                        detectionModel.GateProbability = 0.99;

                        var state=predictedState.Expectation;
                        detectionModel.Condition = state;
                        var detectionProbability = 1 - detectionModel.Evaluate(_zeroCardinality);

                        if(detectionProbability > 0)
                        {
                            rc.DrawMarker(clippingRectangle, screenPointStart, MarkerType.Star, null, GetMarkerSize(hypothesis.Weight), OxyColors.Transparent, sensorColor, 1);
                        }
                    }
                    else
                    {
                        var cartesianSpace = new CartesianSpace {X = double.NaN, Y = double.NaN};
                        _visualization.MeasurementToSystem0(measurement, cartesianSpace);

                        if(double.IsNaN(cartesianSpace.X) || double.IsNaN(cartesianSpace.Y))
                        {
                            continue;
                        }

                        screenPointStart = Transform(cartesianSpace.Y, cartesianSpace.X);

                        rc.DrawMarker(clippingRectangle, screenPointStart, MarkerType.Circle, null, GetMarkerSize(hypothesis.Weight), sensorColor, sensorColor, 1);
                    }

                    var screenPointEnd = Transform(track.State.Expectation.Y,
                        track.State.Expectation.X);

                    const double minimumSegmentLength = 4;

                    var dashArray = LineStyle.Dot.GetDashArray();
                    
                    rc.DrawClippedLine(
                        clippingRectangle,
                        new[] {screenPointStart, screenPointEnd},
                        minimumSegmentLength * minimumSegmentLength,
                        sensorColor,
                        1,
                        dashArray,
                        LineJoin.Miter,
                        false
                    );
                }
            }

            private void RenderAssociationLine1(IRenderContext rc,
                DataFusion1.Association<CameraSpace> association,
                Gaussian<CVComponentsSpace> predictedState, Gaussian<CameraSpace> predictedMeasurement, GaussianTrack<CVComponentsSpace> track)
            {
                var clippingRectangle = GetClippingRect();

                var sensorColor = OxyColor.FromRgb(245, 156, 0);

                foreach (var hypothesis in association.Hypotheses)
                {
                    ScreenPoint screenPointStart;

                    var measurement = hypothesis.Elements.FirstOrDefault();

                    if (measurement == null) //prediction hypothesis
                    {
                        screenPointStart = Transform(predictedState.Expectation.Y, predictedState.Expectation.X);

                        var detectionModel = new DataFusion.CameraDetectionModel()
                        {
                            DetectionAngleMax = _visualization.DetectionAngleMax,
                            DetectionAngleMin = _visualization.DetectionAngleMin,
                            DetectionRangeMax = _visualization.DetectionRangeMax,
                            DetectionRangeMin = _visualization.DetectionRangeMin,
                        };
                        detectionModel.GateProbability = 0.99;

                        var state=predictedState.Expectation;
                        detectionModel.Condition = state;
                        var detectionProbability = 1 - detectionModel.Evaluate(_zeroCardinality);

                        if(detectionProbability > 0)
                        {
                            rc.DrawMarker(clippingRectangle, screenPointStart, MarkerType.Star, null, GetMarkerSize(hypothesis.Weight), OxyColors.Transparent, sensorColor, 1);
                        }
                    }
                    else
                    {
                        var cartesianSpace = new CartesianSpace {X = double.NaN, Y = double.NaN};
                        _visualization.MeasurementToSystem1(measurement, cartesianSpace);

                        if(double.IsNaN(cartesianSpace.X) || double.IsNaN(cartesianSpace.Y))
                        {
                            continue;
                        }

                        screenPointStart = Transform(cartesianSpace.Y, cartesianSpace.X);

                        rc.DrawMarker(clippingRectangle, screenPointStart, MarkerType.Circle, null, GetMarkerSize(hypothesis.Weight), sensorColor, sensorColor, 1);
                    }

                    var screenPointEnd = Transform(track.State.Expectation.Y,
                        track.State.Expectation.X);

                    const double minimumSegmentLength = 4;

                    var dashArray = LineStyle.Dot.GetDashArray();
                    
                    rc.DrawClippedLine(
                        clippingRectangle,
                        new[] {screenPointStart, screenPointEnd},
                        minimumSegmentLength * minimumSegmentLength,
                        sensorColor,
                        1,
                        dashArray,
                        LineJoin.Miter,
                        false
                    );
                }
            }
            private double GetMarkerSize(double weight)
            {
                if (weight < 0.3)
                {
                    return 2;
                }
                else if (weight < 0.6)
                {
                    return 3;
                }
                else if (weight < 0.9)
                {
                    return 4;
                }
                else
                {
                    return 5;
                }
            }

            public override void RenderLegend(IRenderContext rc, OxyRect legendBox)
            {
                var xmid = (legendBox.Left + legendBox.Right) / 2;
                var ymid = (legendBox.Top + legendBox.Bottom) / 2;

                var midpt = new ScreenPoint(xmid, ymid);

                rc.DrawMarker(
                    legendBox,
                    midpt,
                    MarkerType,
                    MarkerOutline,
                    MarkerSize,
                    OxyColors.Transparent,
                    MarkerStroke,
                    MarkerStrokeThickness);
            }

            public TimeSpan PredictionTimeSpan { get; set; }

            protected override void UpdateFromDataFields()
            {
                throw new NotImplementedException();
            }

            private void RenderEllipse(IRenderContext rc, double ellipsePositionX, double ellipsePositionY,
                CovarianceEllipseParameters ellipseParameters)
            {
                var clippingRectangle = GetClippingRect();

                var ellipsePoints = GetEllipsePoints(ellipsePositionX, ellipsePositionY, ellipseParameters.MajorSemiAxis,
                    ellipseParameters.MinorSemiAxis, ellipseParameters.Angle);

                var screenPoints = ellipsePoints.Select(Transform).ToList();
                rc.DrawClippedPolygon(clippingRectangle, screenPoints, 4.0, EllipseFill, EllipseStroke, EllipseStrokeThickness,
                    LineStyle.Dot);
            }

            private static IEnumerable<DataPoint> GetEllipsePoints(double x0, double y0, double majorAxisRadius, double minorAxisRadius, double rotation)
            {
                var cosAlpha = System.Math.Cos(rotation);
                var sinAlpha = System.Math.Sin(rotation);

                for (var pointIndex = 0; pointIndex < EllipsePointsCount; ++pointIndex)
                {
                    var angle = pointIndex * 2 * System.Math.PI / ((double)EllipsePointsCount - 1);
                    var cosT = System.Math.Cos(angle);
                    var sinT = System.Math.Sin(angle);
                    var ellipsePointX = x0 + majorAxisRadius * cosT * cosAlpha - minorAxisRadius * sinT * sinAlpha;
                    var ellipsePointY = y0 + majorAxisRadius * cosT * sinAlpha + minorAxisRadius * sinT * cosAlpha;
                    var ellipsePoint = new DataPoint(ellipsePointY, ellipsePointX);
                    yield return ellipsePoint;
                }
            }

            private void RenderArrow(IRenderContext rc, ICartesianReadOnly start, ICartesianReadOnly end)
            {
                var startPoint = new DataPoint(start.Y, start.X);

                var endPoint =new DataPoint(end.Y, end.X);
                var screenEndPoint = Transform(endPoint);

                var screenStartPoint = Transform(startPoint);

                var d = screenEndPoint - screenStartPoint;
                d.Normalize();
                var n = new ScreenVector(d.Y, -d.X);

                var p1 = screenEndPoint - (d * ArrowHeadLength * ArrowStrokeThickness);
                var p2 = p1 + (n * ArrowHeadWidth * ArrowStrokeThickness);
                var p3 = p1 - (n * ArrowHeadWidth * ArrowStrokeThickness);
                var p4 = p1 + (d * ArrowVeeness * ArrowStrokeThickness);

                var clippingRectangle = GetClippingRect();
                const double minimumSegmentLength = 4;

                var dashArray = LineStyle.Solid.GetDashArray();

                rc.DrawClippedLine(
                    clippingRectangle,
                    new[] { screenStartPoint, p4 },
                    minimumSegmentLength * minimumSegmentLength,
                    GetSelectableColor(ArrowColor),
                    ArrowStrokeThickness,
                    dashArray,
                    LineJoin.Miter,
                    false);

                rc.DrawClippedPolygon(
                    clippingRectangle,
                    new[] { p3, screenEndPoint, p2, p4 },
                    minimumSegmentLength * minimumSegmentLength,
                    GetSelectableColor(ArrowColor),
                    OxyColors.Undefined);
            }

            protected virtual double GetEgoVelocity()
            {
                return 0;
            }

            protected virtual double GetEgoYawrate()
            {
                return 0;
            }
        }

        private class TrackPoint : ScatterPoint
        {
            private const int MahalanobisDistance = 6;

            public TrackPoint(DateTime time, GaussianTrack<CVComponentsSpace> track, DataFusion.CVVectorialModel systemModel)
                : base(track.State.Expectation.Y, track.State.Expectation.X, value:GetColorValue(track), tag: track)
            {
                Time = time;
                CovarianceEllipseParameters = track.State.GetCovarianceEllipseParameters(MahalanobisDistance);
                SystemModel = systemModel;
            }

            public DateTime Time { get; private set; }

            public GaussianTrack<CVComponentsSpace> Track
            {
                get { return (GaussianTrack<CVComponentsSpace>)Tag; }
            }

            public Gaussian<CVComponentsSpace> PredictedState0 { get; set; }

            public Gaussian<RadarSpace> PredictedMeasurement0 { get; set; }

            public IEnumerable<DataFusion1.Association<RadarSpace>> Associations0 { get; set; }

            public Gaussian<CVComponentsSpace> PredictedState1 { get; set; }

            public Gaussian<CameraSpace> PredictedMeasurement1 { get; set; }

            public IEnumerable<DataFusion1.Association<CameraSpace>> Associations1 { get; set; }
            public DataFusion.CVVectorialModel SystemModel { get; private set; }

            public CovarianceEllipseParameters CovarianceEllipseParameters { get; private set; }

            private static double GetColorValue(GaussianTrack<CVComponentsSpace> track)
            {
                var random = new Random((int)track.ID);
                var colorValue = random.NextDouble();
                return colorValue;
            }
        }

        private class FieldOfViewAnnotation : Annotation
        {
            private const int CellsYCount = 400;
            private const int CellsXCount = 700;

            private OxyImage _image;

            private double _x0;
            private double _x1;
            private double _y0;
            private double _y1;

            private readonly object _fovImageLock = new object();
            public IColorAxis ColorAxis0 { get; set; }
            public IColorAxis ColorAxis1 { get; set; }
            #region Parameters

            
            #region System properties
            
            public System.Double SigmaAccelerationX
            {
                get;
                set;
            }
            
            public System.Double SigmaAccelerationY
            {
                get;
                set;
            }
            
            #endregion System properties
            
            #region RadarSensor measurement model
            
            public System.Double SensorPositionX
            {
                get;
                set;
            }
            
            public System.Double SensorPositionY
            {
                get;
                set;
            }
            
            public System.Double SensorRotationZ
            {
                get;
                set;
            }
            
            public System.Double SigmaAzimuth
            {
                get;
                set;
            }
            
            public System.Double SigmaRange
            {
                get;
                set;
            }
            
            public System.Double SigmaRangeRate
            {
                get;
                set;
            }
            
            #endregion RadarSensor measurement model
            
            #region RadarSensor detection model
            
            public System.Double DetectionAngleMax
            {
                get;
                set;
            }
            
            public System.Double DetectionAngleMin
            {
                get;
                set;
            }
            
            public System.Double DetectionRangeMax
            {
                get;
                set;
            }
            
            public System.Double DetectionRangeMin
            {
                get;
                set;
            }
            
            #endregion RadarSensor detection model
            
            #region RadarSensor track proposer
            
            public System.Double SigmaVx
            {
                get;
                set;
            }
            
            public System.Double SigmaVy
            {
                get;
                set;
            }
            
            public System.Double SigmaX
            {
                get;
                set;
            }
            
            public System.Double SigmaY
            {
                get;
                set;
            }
            
            public System.Double InitialExistenceProbability
            {
                get;
                set;
            }
            
            #endregion RadarSensor track proposer
            
            #region CameraSensor measurement model
            
            public System.Double SigmaColumn
            {
                get;
                set;
            }
            
            public System.Double SigmaRow
            {
                get;
                set;
            }
            
            #endregion CameraSensor measurement model
            
            #region Track removers
            
            public System.Double MinimumExistenceProbability
            {
                get;
                set;
            }
            
            #endregion Track removers

            #endregion

            public FieldOfViewAnnotation()
            {
                Layer = AnnotationLayer.BelowAxes;
            }

            public void CalculateFOVImage()
            {
                var m = CellsYCount;
                var n = CellsXCount;

                var x0 = PlotModel.DefaultYAxis.ActualMinimum;
                var x1 = PlotModel.DefaultYAxis.ActualMaximum;
                var y0 = PlotModel.DefaultXAxis.ActualMinimum;
                var y1 = PlotModel.DefaultXAxis.ActualMaximum;

                var newImage = CreateImage(m, n, x0, x1, y0, y1);

                lock (_fovImageLock)
                {
                    _image = newImage;
                    _x0 = x0;
                    _x1 = x1;
                    _y0 = y0;
                    _y1 = y1;
                }
            }

            public override void Render(IRenderContext rc)
            {
                base.Render(rc);

                EnsureAxes();

                OxyImage image = null;
                double bottom;
                double top;
                double left;
                double right;
                lock (_fovImageLock)
                {
                    image = _image;
                    bottom = _x0;
                    top = _x1;
                    left = _y0;
                    right = _y1;
                }

                if (image == null)
                {
                    return;
                }

                var m = CellsYCount;
                var n = CellsXCount;
                var dx = (top - bottom) / (m - 1);
                var dy = (right - left) / (n - 1);

                left -= dx / 2;
                right += dx / 2;

                bottom -= dy / 2;
                top += dy / 2;

                var s00 = Transform(left, bottom);
                var s11 = Transform(right, top);
                var rect = new OxyRect(s00, s11);

                var clip = GetClippingRect();

                rc.DrawClippedImage(clip, image, rect.Left, rect.Top, rect.Width, rect.Height, 1, true);
            }

            private OxyImage CreateImage(int cellsYCount, int cellsXCount, double xMin, double xMax, double yMin, double yMax)
            {
                var reverseX = XAxis.Transform(xMin) > XAxis.Transform(xMax);
                var reverseY = YAxis.Transform(yMin) > YAxis.Transform(yMax);
                var pixels=new OxyColor[cellsYCount, cellsXCount];

                var fov0 = new double[cellsYCount, cellsXCount];
                GetDetectionProbabilities0(fov0, xMin, xMax, yMin, yMax);
                var fov1 = new double[cellsYCount, cellsXCount];
                GetDetectionProbabilities1(fov1, xMin, xMax, yMin, yMax);

                for (int i = 0; i < cellsYCount; i++)
                {
                    var ii = reverseX ? cellsYCount - 1 - i : i;
                    for (int j = 0; j < cellsXCount; j++)
                    {
                        var jj = reverseY ? cellsXCount - 1 - j : j;
                        Color result = Color.White;
                        var color0 = ColorAxis0.GetColor(fov0[ii, jj]);
                        result = AlphaBlend(color0, result);
                        var color1 = ColorAxis1.GetColor(fov1[ii, jj]);
                        result = AlphaBlend(color1, result);
                        pixels[i, j] = OxyColor.FromArgb(result.A, result.R, result.G, result.B);
                    }
                }

                var image = OxyImage.Create(pixels, ImageFormat.Png);

                return image;
            }

            private static Color AlphaBlend(OxyColor source, Color background)
            {
                var sourceAlpha = source.A;
                var backgroundAlpha = background.A;
                var red = MixColorComponent(source.R, sourceAlpha, background.R, backgroundAlpha);
                var green = MixColorComponent(source.G, sourceAlpha, background.G, backgroundAlpha);
                var blue = MixColorComponent(source.B, sourceAlpha, background.B, backgroundAlpha);
                var alpha = MixAlpha(sourceAlpha, backgroundAlpha);
                return Color.FromArgb(alpha, red, green, blue);
            }

            private static byte MixColorComponent(byte source, byte sourceAlpha, byte background, byte backgroundAlpha)
            {
                var mixRatio = 1.0 - sourceAlpha / 255.0;
                return (byte)(source * sourceAlpha / 255.0 + background * backgroundAlpha / 255.0 * mixRatio);
            }

            private static byte MixAlpha(byte sourceAlpha, byte backgroundAlpha)
            {
                return (byte)(sourceAlpha + backgroundAlpha * (1.0 - sourceAlpha / 255.0));
            }
            private void GetDetectionProbabilities0(double[,] fov, double xMin, double xMax, double yMin, double yMax)
            {
                var detectionModel = new DataFusion.RadarDetectionModel()
                {
                    DetectionAngleMax = this.DetectionAngleMax,
                    DetectionAngleMin = this.DetectionAngleMin,
                    DetectionRangeMax = this.DetectionRangeMax,
                    DetectionRangeMin = this.DetectionRangeMin,
                };
                detectionModel.GateProbability = 0.99;

                var fieldOfViewProvider = new FieldOfViewProvider<DataFusion.RadarDetectionModel, CVComponentsSpace>(detectionModel);
                fieldOfViewProvider.FillFieldOfView(xMin, xMax, yMin, yMax, fov);
            }
            private void GetDetectionProbabilities1(double[,] fov, double xMin, double xMax, double yMin, double yMax)
            {
                var detectionModel = new DataFusion.CameraDetectionModel()
                {
                    DetectionAngleMax = this.DetectionAngleMax,
                    DetectionAngleMin = this.DetectionAngleMin,
                    DetectionRangeMax = this.DetectionRangeMax,
                    DetectionRangeMin = this.DetectionRangeMin,
                };
                detectionModel.GateProbability = 0.99;

                var fieldOfViewProvider = new FieldOfViewProvider<DataFusion.CameraDetectionModel, CVComponentsSpace>(detectionModel);
                fieldOfViewProvider.FillFieldOfView(xMin, xMax, yMin, yMax, fov);
            }
            protected virtual double GetEgoVelocity()
            {
                return 0;
            }

            protected virtual double GetEgoYawrate()
            {
                return 0;
            }
        }

        internal class DebounceTimer
        {
            private System.Timers.Timer _timerThreading;

            public void Debounce(TimeSpan interval, Action<object> action,
                object param = null)
            {
                if (_timerThreading != null)
                {
                    _timerThreading.Stop();
                }
                _timerThreading = null;
                _timerThreading = new System.Timers.Timer(interval.TotalMilliseconds) { AutoReset = false };
                _timerThreading.Elapsed += (sender, args) =>
                {
                    if (_timerThreading == null)
                    {
                        return;
                    }
                    if (_timerThreading != null)
                    {
                        _timerThreading.Stop();
                    }
                    _timerThreading = null;
                    action.Invoke(param);
                };
                _timerThreading.Start();
            }
        }

    }

}

namespace DataFusion.WindowsForms
{
    using System.Windows.Forms;
    using OxyPlot.WindowsForms;
    // Prevents a bug in Mono that does not allow to use the mouse wheel for zooming on Windows.
    // The mouse wheel event arguments deliver screen coordinates instead of widget coordinates.
    internal class WindowsMonoPlotView : PlotView
    {
        protected override void OnMouseWheel(MouseEventArgs e)
        {
            // retrieve window position 
            // this.Parent.Parent == plotView.VisualizationControl.Form
            var x = this.Parent.Parent.Left;
            var y = this.Parent.Parent.Top;
            // widget coordinate = screen.coordinate - window.position
            var xNew = e.X - x;
            var yNew = e.Y - y;
            var eNew = new MouseEventArgs(e.Button, e.Clicks, xNew, yNew, e.Delta);
            base.OnMouseWheel(eNew);
        }
    }
    public partial class DataFusion1VisualizationControl : UserControl
    {
        private readonly DataFusion1Visualization _visualization;
        private readonly TimeSpan _defaultFOVUpdateInterval = TimeSpan.FromMilliseconds(700);
        private readonly DataFusion1Visualization.DebounceTimer _fovTimer = new DataFusion1Visualization.DebounceTimer();
        private Point _rightMouseDownPosition;
        private Point _middleMouseDownPosition;
        private readonly PlotView _plotView;
        private bool _shouldRender;

        public DataFusion1VisualizationControl()
        {
            _visualization = new DataFusion1Visualization();
            _plotView = CreateControl(_visualization);
            Controls.Add(_plotView);

            var renderTimer = new Timer { Interval = 150 };
            renderTimer.Tick += Render;
            renderTimer.Start();
        }

        [System.ComponentModel.DefaultValue("Data Fusion")]
        [System.ComponentModel.DisplayName("Tracks legend title")]
        public string TracksLegendTitle
        {
            get { return _visualization.TracksLegendTitle; }
            set { _visualization.TracksLegendTitle = value; }
        }

        [System.ComponentModel.DefaultValue(DataFusion1Visualization.DefaultExistenceProbabilityMin)]
        [System.ComponentModel.DisplayName("Minimum existence probability")]
        [System.ComponentModel.Description("A track is shown if its existence probability is above this value.")]
        public double ExistenceProbabilityMin
        {
            get { return _visualization.ExistenceProbabilityMin; }
            set { _visualization.ExistenceProbabilityMin = value; }
        }

        [System.ComponentModel.DefaultValue(DataFusion1Visualization.DefaultPredictionTimeSpan)]
        [System.ComponentModel.DisplayName("Prediction time span [ms]")]
        [System.ComponentModel.Description("Predicts tracks to this time to determine the end points of the track direction arrows. Set to 0 to disable track direction arrows.")]
        public int PredictionTimeSpan
        {
            get
            {
                return (int)_visualization.PredictionTimeSpan.TotalMilliseconds;
            }
            set
            {
                _visualization.PredictionTimeSpan = TimeSpan.FromMilliseconds(value);
            }
        }
                /// <summary>
        /// Sets 'RadarSensor' measurements.
        /// </summary>
        /// <param name="time">The time of the measurements.</param>
        /// <param name="measurements">The 'RadarSensor' measurements.</param>
        public void SetMeasurements0(DateTime time, IEnumerable<RadarSpace> measurements)
        {
            _visualization.SetMeasurements0(time, measurements);
            _shouldRender = true;
        }

        public void SetPredictions0(
            IEnumerable<DataFusion1.Prediction<CVComponentsSpace, RadarSpace>> predictions)
        {
            _visualization.SetPredictions0(predictions);
        }

        public void SetAssociations0(
            IEnumerable<DataFusion1.Association<RadarSpace>> associations)
        {
            _visualization.SetAssociations0(associations);
        }
                /// <summary>
        /// Sets 'CameraSensor' measurements.
        /// </summary>
        /// <param name="time">The time of the measurements.</param>
        /// <param name="measurements">The 'CameraSensor' measurements.</param>
        public void SetMeasurements1(DateTime time, IEnumerable<CameraSpace> measurements)
        {
            _visualization.SetMeasurements1(time, measurements);
            _shouldRender = true;
        }

        public void SetPredictions1(
            IEnumerable<DataFusion1.Prediction<CVComponentsSpace, CameraSpace>> predictions)
        {
            _visualization.SetPredictions1(predictions);
        }

        public void SetAssociations1(
            IEnumerable<DataFusion1.Association<CameraSpace>> associations)
        {
            _visualization.SetAssociations1(associations);
        }
                /// <summary>
        /// Sets the tracks.
        /// </summary>
        /// <param name="time">The time of the tracks.</param>
        /// <param name="tracks">The tracks.</param>
        public void SetTracks(DateTime time, IEnumerable<GaussianTrack<CVComponentsSpace>> tracks)
        {
            _visualization.SetTracks(time, tracks);
            _shouldRender = true;
        }

        private TimeSpan FOVUpdateInterval { get; set; }

        private PlotView CreateControl(DataFusion1Visualization vis)
        {
            FOVUpdateInterval = _defaultFOVUpdateInterval;
            var isWindows = Environment.OSVersion.Platform == PlatformID.Win32NT;
            var isRunningOnMono = (Type.GetType("Mono.Runtime") != null);
            var isWindowsAndMono = (isWindows && isRunningOnMono);

            var plotView = (isWindowsAndMono) ? new WindowsMonoPlotView() : new PlotView() ;
            plotView.Model = vis.PlotModel;
            plotView.Dock = DockStyle.Fill;

            _rightMouseDownPosition = new Point();
            _middleMouseDownPosition = new Point();

            this.HandleCreated += (eventSender, eventArgs) =>
            {
                plotView.MouseWheel += (sender, args) =>
                {
                    UpdateFieldOfView();
                };

                plotView.MouseDown += OnMouseDown;

                plotView.MouseUp += OnMouseUp;

                plotView.SizeChanged += (sender, args) =>
                {
                    UpdateFieldOfView();
                };

                UpdateFieldOfView();

            };

            return plotView;
        }

        private void UpdateFieldOfView()
        {
            _fovTimer.Debounce(FOVUpdateInterval, (p) =>
            {
                _visualization.UpdateFieldOfView();
                if (IsHandleCreated)
                {
                    this.Invoke(new Action(() => _plotView.Model.InvalidatePlot(true)));
                }
            });
        }

        private void Render(object sender, EventArgs e)
        {
            if(!_shouldRender)
            {
                return;
            }

            _visualization.Render();

            _shouldRender = false;
        }

        private void OnMouseDown(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Right)
            {
                _rightMouseDownPosition = e.Location;
            }
            else if (e.Button == MouseButtons.Middle)
            {
                _middleMouseDownPosition = e.Location;
            }
            else if (e.Button == MouseButtons.Left)
            {
            }
        }

        private void OnMouseUp(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Right)
            {
                if (e.Location == _rightMouseDownPosition)
                {
                    return;
                }
            }
            else if (e.Button == MouseButtons.Middle)
            {
                if (e.Location == _middleMouseDownPosition)
                {
                    return;
                }
            }
            else
            {
                return;
            }

            UpdateFieldOfView();
        }
    }

    public partial class DataFusion1VisualizationForm : Form
    {
        public DataFusion1VisualizationForm()
        {
            Control = new DataFusion1VisualizationControl
            {
                Dock = DockStyle.Fill
            };

            Controls.Add(Control);

            #region Must remain unchanged according to license terms and conditions

            Icon = GetBaselabsCreateIcon();

            Load += (sender, args) =>
            {
                Text = @"BASELABS Create - DataFusion";
            };

            #endregion Must remain unchanged according to license terms and conditions

            Shown += (sender, args) =>
            {
                var width = Screen.PrimaryScreen.WorkingArea.Width / 3;
                Location = new Point(Screen.PrimaryScreen.WorkingArea.Width - width, 0);
                Width = width;
                Height = Screen.PrimaryScreen.WorkingArea.Height;
            };
        }

        public DataFusion1VisualizationControl Control{ get; private set; }

        #region Must remain unchanged according to license terms and conditions

        private static System.Drawing.Icon GetBaselabsCreateIcon()
        {
            var assembly = typeof(Space).Assembly;
            const string resourceName = "Baselabs.Statistics.BaselabsCreate.png";

            using (var stream = assembly.GetManifestResourceStream(resourceName))
            {
                var image = (Bitmap)Image.FromStream(stream);
                return System.Drawing.Icon.FromHandle(image.GetHicon());
            }
        }

        #endregion Must remain unchanged according to license terms and conditions
    }
}

namespace DataFusion.Gtk
{
    using System.Threading;

    public partial class DataFusion1VisualizationPlotView : OxyPlot.GtkSharp.PlotView
    {
        private readonly DataFusion1Visualization _visualization;
        private readonly TimeSpan _defaultFOVUpdateInterval = TimeSpan.FromMilliseconds(700);
        private readonly DataFusion1Visualization.DebounceTimer _fovTimer = new DataFusion1Visualization.DebounceTimer();
        private Point _rightMouseDownPosition;
        private Point _middleMouseDownPosition;
        private bool _shouldRender;
        private Timer _renderTimer;

        public DataFusion1VisualizationPlotView()
        {
            _visualization = new DataFusion1Visualization();
            SetupControl(_visualization);
            _renderTimer = new Timer(state => global::Gtk.Application.Invoke((o, e) => { Render(); }), null, 0, 150);
        }

        [System.ComponentModel.DefaultValue("Data Fusion")]
        [System.ComponentModel.DisplayName("Tracks legend title")]
        public string TracksLegendTitle
        {
            get { return _visualization.TracksLegendTitle; }
            set { _visualization.TracksLegendTitle = value; }
        }

        [System.ComponentModel.DefaultValue(DataFusion1Visualization.DefaultExistenceProbabilityMin)]
        [System.ComponentModel.DisplayName("Minimum existence probability")]
        [System.ComponentModel.Description("A track is shown if its existence probability is above this value.")]
        public double ExistenceProbabilityMin
        {
            get { return _visualization.ExistenceProbabilityMin; }
            set { _visualization.ExistenceProbabilityMin = value; }
        }

        [System.ComponentModel.DefaultValue(DataFusion1Visualization.DefaultPredictionTimeSpan)]
        [System.ComponentModel.DisplayName("Prediction time span [ms]")]
        [System.ComponentModel.Description("Predicts tracks to this time to determine the end points of the track direction arrows. Set to 0 to disable track direction arrows.")]
        public int PredictionTimeSpan
        {
            get
            {
                return (int)_visualization.PredictionTimeSpan.TotalMilliseconds;
            }
            set
            {
                _visualization.PredictionTimeSpan = TimeSpan.FromMilliseconds(value);
            }
        }

        
        /// <summary>
        /// Sets 'RadarSensor' measurements.
        /// </summary>
        /// <param name="time">The time of the measurements.</param>
        /// <param name="measurements">The 'RadarSensor' measurements.</param>
        public void SetMeasurements0(DateTime time, IEnumerable<RadarSpace> measurements)
        {
            _visualization.SetMeasurements0(time, measurements);
            _shouldRender = true;
        }

        public void SetPredictions0(
            IEnumerable<DataFusion1.Prediction<CVComponentsSpace, RadarSpace>> predictions)
        {
            _visualization.SetPredictions0(predictions);
        }

        public void SetAssociations0(
            IEnumerable<DataFusion1.Association<RadarSpace>> associations)
        {
            _visualization.SetAssociations0(associations);
        }
        
        /// <summary>
        /// Sets 'CameraSensor' measurements.
        /// </summary>
        /// <param name="time">The time of the measurements.</param>
        /// <param name="measurements">The 'CameraSensor' measurements.</param>
        public void SetMeasurements1(DateTime time, IEnumerable<CameraSpace> measurements)
        {
            _visualization.SetMeasurements1(time, measurements);
            _shouldRender = true;
        }

        public void SetPredictions1(
            IEnumerable<DataFusion1.Prediction<CVComponentsSpace, CameraSpace>> predictions)
        {
            _visualization.SetPredictions1(predictions);
        }

        public void SetAssociations1(
            IEnumerable<DataFusion1.Association<CameraSpace>> associations)
        {
            _visualization.SetAssociations1(associations);
        }
        
        /// <summary>
        /// Sets the tracks.
        /// </summary>
        /// <param name="time">The time of the tracks.</param>
        /// <param name="tracks">The tracks.</param>
        public void SetTracks(DateTime time, IEnumerable<GaussianTrack<CVComponentsSpace>> tracks)
        {
            _visualization.SetTracks(time, tracks);
            _shouldRender = true;
        }

        private TimeSpan FOVUpdateInterval { get; set; }

        private void SetupControl(DataFusion1Visualization vis)
        {
            FOVUpdateInterval = _defaultFOVUpdateInterval;

            Events = Gdk.EventMask.AllEventsMask;

            Model = vis.PlotModel;

            _rightMouseDownPosition = new Point();
            _middleMouseDownPosition = new Point();

            UpdateFieldOfView();
        }

        private void UpdateFieldOfView()
        {
            _fovTimer.Debounce(FOVUpdateInterval, (p) =>
            {
                _visualization.UpdateFieldOfView();
                global::Gtk.Application.Invoke((o, e) =>
                {
                    try
                    {
                        Model.InvalidatePlot(true);
                    }
                    catch { }
                });
            });
        }

        private void Render()
        {
            if (!_shouldRender)
            {
                return;
            }

            _visualization.Render();

            _shouldRender = false;
        }

        enum GtkButton : uint
        {
            Left = 1,
            Middle = 2,
            Right = 3
        }

        protected override void OnSizeAllocated(Gdk.Rectangle allocation)
        {
            UpdateFieldOfView();
            base.OnSizeAllocated(allocation);
        }

        protected override bool OnScrollEvent(Gdk.EventScroll e)
        {
            e.Direction = DetermineScrollDirection(e);
            UpdateFieldOfView();
            return base.OnScrollEvent(e);
        }

        protected override bool OnButtonPressEvent(Gdk.EventButton e)
        {
            if ((GtkButton)e.Button == GtkButton.Right)
            {
                _rightMouseDownPosition = GetPoint(e);
            }
            else if ((GtkButton)e.Button == GtkButton.Middle)
            {
                _middleMouseDownPosition = GetPoint(e);
            }
            else if ((GtkButton)e.Button == GtkButton.Left)
            {
            }

            return base.OnButtonPressEvent(e);
        }

        protected override bool OnButtonReleaseEvent(Gdk.EventButton e)
        {
            if ((GtkButton)e.Button == GtkButton.Right)
            {
                if (GetPoint(e) == _rightMouseDownPosition)
                {
                    return base.OnButtonReleaseEvent(e);
                }
            }
            else if ((GtkButton)e.Button == GtkButton.Middle)
            {
                if (GetPoint(e) == _middleMouseDownPosition)
                {
                    return base.OnButtonReleaseEvent(e);
                }
            }
            else
            {
                return base.OnButtonReleaseEvent(e);
            }

            UpdateFieldOfView();

            return base.OnButtonReleaseEvent(e);
        }

        private Point GetPoint(Gdk.EventButton eventButton)
        {
            return new Point((int)eventButton.X, (int)eventButton.Y);
        }

        private Gdk.ScrollDirection DetermineScrollDirection(Gdk.EventScroll e)
        {
            var nativeScrollEvent = (GdkNativeScrollStruct)System.Runtime.InteropServices.Marshal.PtrToStructure(e.Handle, typeof(GdkNativeScrollStruct));
            return nativeScrollEvent.delta_y > 0 ? Gdk.ScrollDirection.Down : Gdk.ScrollDirection.Up;
        }

        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
        struct GdkNativeScrollStruct
        {
            private Gdk.EventType type;
            private IntPtr window;
            private sbyte send_event;
            public uint time;
            public double x;
            public double y;
            public uint state;
            public Gdk.ScrollDirection direction;
            public IntPtr device;
            public double x_root;
            public double y_root;
            public double delta_x;
            public double delta_y;
        }
    }

    public partial class DataFusion1VisualizationWindow : global::Gtk.Window
    {
        public DataFusion1VisualizationWindow() : base(global::Gtk.WindowType.Toplevel)
        {
            Events = Gdk.EventMask.AllEventsMask;
            Control = new DataFusion1VisualizationPlotView();

            var hbox1 = new global::Gtk.HBox
            {
                Events = Gdk.EventMask.AllEventsMask
            };
            hbox1.PackStart(Control, true, true, 0);
            Add(hbox1);

            #region Must remain unchanged according to license terms and conditions

            Icon = GetBaselabsCreateIcon();

            #endregion Must remain unchanged according to license terms and conditions
        }

        public DataFusion1VisualizationPlotView Control { get; private set; }

        protected override void OnShown()
        {
            #region Must remain unchanged according to license terms and conditions

            Title = @"BASELABS Create - DataFusion";
            #endregion Must remain unchanged according to license terms and conditions

            var width = Display.DefaultScreen.Width / 3;
            Move(Display.DefaultScreen.Width - width, 0);
            Resize(width, Display.DefaultScreen.Height);

            base.OnShown();
        }

        #region Must remain unchanged according to license terms and conditions

        private static Gdk.Pixbuf GetBaselabsCreateIcon()
        {
            var assembly = typeof(Space).Assembly;
            const string resourceName = "Baselabs.Statistics.BaselabsCreate.png";

            using (var stream = assembly.GetManifestResourceStream(resourceName))
            {
                var pixelBuffer = new Gdk.Pixbuf(stream);
                return pixelBuffer;
            }
        }

        #endregion Must remain unchanged according to license terms and conditions
    }
}namespace DataFusion
{
    internal partial class DataFusion1VisualizationConnector : IDisposable
    {
        private readonly bool _isWindows = Environment.OSVersion.Platform == PlatformID.Win32NT;
        private WindowsForms.DataFusion1VisualizationForm _form;
        private Gtk.DataFusion1VisualizationWindow _window;
        private DateTime _time0;
        private DateTime _time1;
        private readonly ManualResetEvent _uiCreatedEvent = new ManualResetEvent(false);

        public DataFusion1VisualizationConnector(DataFusion1 dataFusion)
        {
            if(_isWindows)
            {
                new System.Threading.Tasks.Task(ShowForm).Start();
            }
            else
            {
                new System.Threading.Tasks.Task(ShowWindow).Start();
            }
            _uiCreatedEvent.WaitOne();
            SetupDataFusionCallbacks(dataFusion);
        }

        public void Dispose()
        {
            if(_isWindows)
            {
                InvokeCloseForm();
            }
            else
            {
                InvokeCloseWindow();
            }
        }

        private void SetTracksWinForms(System.DateTime time, IEnumerable<GaussianTrack<CVComponentsSpace>> tracks)
        {
            _form.Control.SetTracks(time, tracks);
        }
        private void SetTracksGtk(System.DateTime time, IEnumerable<GaussianTrack<CVComponentsSpace>> tracks)
        {
            _window.Control.SetTracks(time, tracks);
        }

        private void SetMeasurementsWinForms0(System.DateTime time, IEnumerable<RadarSpace> measurements)
        {
            _form.Control.SetMeasurements0(time, measurements);
        }

        private void SetPredictionsWinForms0(IEnumerable<DataFusion1.Prediction<CVComponentsSpace, RadarSpace>> predictions)
        {
            _form.Control.SetPredictions0(predictions);
        }

        private void SetAssociationsWinForms0(IEnumerable<DataFusion1.Association<RadarSpace>> associations)
        {
            _form.Control.SetAssociations0(associations);
        }
        private void SetMeasurementsGtk0(System.DateTime time, IEnumerable<RadarSpace> measurements)
        {
            _window.Control.SetMeasurements0(time, measurements);
        }

        private void SetPredictionsGtk0(IEnumerable<DataFusion1.Prediction<CVComponentsSpace, RadarSpace>> predictions)
        {
            _window.Control.SetPredictions0(predictions);
        }

        private void SetAssociationsGtk0(IEnumerable<DataFusion1.Association<RadarSpace>> associations)
        {
            _window.Control.SetAssociations0(associations);
        }

        private void SetMeasurementsWinForms1(System.DateTime time, IEnumerable<CameraSpace> measurements)
        {
            _form.Control.SetMeasurements1(time, measurements);
        }

        private void SetPredictionsWinForms1(IEnumerable<DataFusion1.Prediction<CVComponentsSpace, CameraSpace>> predictions)
        {
            _form.Control.SetPredictions1(predictions);
        }

        private void SetAssociationsWinForms1(IEnumerable<DataFusion1.Association<CameraSpace>> associations)
        {
            _form.Control.SetAssociations1(associations);
        }
        private void SetMeasurementsGtk1(System.DateTime time, IEnumerable<CameraSpace> measurements)
        {
            _window.Control.SetMeasurements1(time, measurements);
        }

        private void SetPredictionsGtk1(IEnumerable<DataFusion1.Prediction<CVComponentsSpace, CameraSpace>> predictions)
        {
            _window.Control.SetPredictions1(predictions);
        }

        private void SetAssociationsGtk1(IEnumerable<DataFusion1.Association<CameraSpace>> associations)
        {
            _window.Control.SetAssociations1(associations);
        }
        private void ShowForm()
        {
            _form = new WindowsForms.DataFusion1VisualizationForm();

            _uiCreatedEvent.Set();

            System.Windows.Forms.Application.Run(_form);
        }

        private void SetupDataFusionCallbacks(DataFusion1 dataFusion)
        {

            dataFusion.Processing0 += (time, measurements) =>
            {
                _time0 = time;
                if(_isWindows)
                {
                    SetMeasurementsWinForms0(time, measurements);
                }
                else
                {
                    SetMeasurementsGtk0(time, measurements);
                }
            };

            IEnumerable<DataFusion1.Prediction<CVComponentsSpace, RadarSpace>> predictions0 = null;

            dataFusion.Predicted0 += predictions => 
            { 
                predictions0 = predictions;
            };

            IEnumerable<DataFusion1.Association<RadarSpace>> associations0 = null;

            dataFusion.Associated0 += associations =>
            {
                associations0 = associations;
            };

            dataFusion.Processed0 += () =>
            {
                IEnumerable<GaussianTrack<CVComponentsSpace>> tracks;
                if(dataFusion.GetTracks(_time0, out tracks))
                {
                    if(_isWindows)
                    {
                        SetPredictionsWinForms0(predictions0); 
                        SetAssociationsWinForms0(associations0);
                        SetTracksWinForms(_time0, tracks);
                    }
                    else
                    {
                        SetPredictionsGtk0(predictions0); 
                        SetAssociationsGtk0(associations0);
                        SetTracksGtk(_time0, tracks);
                    }
                }
            };

            dataFusion.Processing1 += (time, measurements) =>
            {
                _time1 = time;
                if(_isWindows)
                {
                    SetMeasurementsWinForms1(time, measurements);
                }
                else
                {
                    SetMeasurementsGtk1(time, measurements);
                }
            };

            IEnumerable<DataFusion1.Prediction<CVComponentsSpace, CameraSpace>> predictions1 = null;

            dataFusion.Predicted1 += predictions => 
            { 
                predictions1 = predictions;
            };

            IEnumerable<DataFusion1.Association<CameraSpace>> associations1 = null;

            dataFusion.Associated1 += associations =>
            {
                associations1 = associations;
            };

            dataFusion.Processed1 += () =>
            {
                IEnumerable<GaussianTrack<CVComponentsSpace>> tracks;
                if(dataFusion.GetTracks(_time1, out tracks))
                {
                    if(_isWindows)
                    {
                        SetPredictionsWinForms1(predictions1); 
                        SetAssociationsWinForms1(associations1);
                        SetTracksWinForms(_time1, tracks);
                    }
                    else
                    {
                        SetPredictionsGtk1(predictions1); 
                        SetAssociationsGtk1(associations1);
                        SetTracksGtk(_time1, tracks);
                    }
                }
            };

        }

        private void InvokeCloseForm()
        {
            if(_form.InvokeRequired)
            {
                _form.Invoke(new Action(CloseForm));
            }
            else
            {
                CloseForm();
            }
        }

        private void CloseForm()
        {
            _form.Close();
        }
        private void ShowWindow()
        {
            global::Gtk.Application.Init();

            _window = new Gtk.DataFusion1VisualizationWindow();
            _window.ShowAll();

            _uiCreatedEvent.Set();

            global::Gtk.Application.Run();
        }

        private void InvokeCloseWindow()
        {
            global::Gtk.Application.Invoke((o,e)=> { CloseWindow(o,e); });
        }

        private void CloseWindow(object sender, EventArgs e)
        {
            _window.Destroy();
        }    }
}


